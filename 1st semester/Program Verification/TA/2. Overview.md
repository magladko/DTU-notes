# Assignment 1
## T1: Warmup: verification with CHI (10 pts)

### Program (a) 

```
{ true }
if x < 10 -> skip 
[] x <= 10 -> x := 10 
fi 
{ TODO } 
```

```
{ true }
if x < 10 -> skip
[] x <= 10 -> x := 10
fi
{ x <= 10 }
```

### Program (b) 

```
{ true } 
if x > y -> temp := x; x := y; y := temp 
[] y > z -> temp := y; y := z; z := temp 
fi; 
if x > y -> temp := x; x := y; y := temp 
fi 
{ TODO } 
```

```
{ true } 
if x > y -> temp := x; x := y; y := temp // x'=y, y'=x
[] y > z -> temp := y; y := z; z := temp // y'=z, z'=y
fi;
if x > y -> temp := x; x := y; y := temp // x'=y',y''=x'
fi                                       // x'=z, y''=z
{ x <= y & x < z}

```

### Program (c) 

```
{ TODO } 
if x > y -> temp := x; x := y; y := temp 
[] x <= y -> skip fi; 
{ TODO } 
if x >= y -> z := x 
[] y > x -> z := y 
fi 
{ z = y }
```

```
{ true }
{ (x <= y ==> (x >= y ==> x = y)) & (x > y ==> (y >= x ==> y = x)) }
if x > y -> { y >= x ==> y = x } temp := x; { y >= temp ==> y = temp } x := y; { x >= temp ==> x = temp } y := temp { x >= y ==> x = y }
[] x <= y -> skip
fi;
{ x >= y ==> x = y }
{ (x >= y ==> x = y) & (y > x ==> y = y) }
if x >= y -> { x = y } z := x { z = y }
[] y > x -> { y = y } z := y { z = y }
fi 
{ z = y }

```

## T2: Operational semantics (10 pts)

| Variable | $\mem(x)$ |
| -------- | --------- |
| $x$      | 4         |
| $y$      | -2        |
| $z$      | 0         |
### (a) Apply the formal semantics of arithmetic expressions to evaluate the following:
![[2. Overview - Table 2-4.png]]
#### (i)

$$
\begin{align}
&[x + y + 5](\mem) \\
=\ &[x + y](\mem) + [5](\mem) \\
=\ &[x](\mem) + [y](\mem) + 5 \\
=\ &\mem(x) + \mem(y)+ 5 \\
=\ &4 + (-2) + 5 \\
=\ &7 \\
\end{align}
$$
#### (ii)
\*?
$$
\begin{align}
&[x * (x + z)](\mem\subst{y}{3}) \\
=\ & \mUpdate{x}{y} \\

\end{align}
$$

### (b)

$$
\begin{align*}
  & 
  \tuple{\Ite{\x > 0}{\Assign{\y}{\x+\y}}{\Assign{\z}{\x-\y}}\Seq\Assign{\x}{\z+1}\tsep \mem} \\
  \opStep\quad &
  \tuple{\Assign{\y}{\x+\y}\Seq\Assign{\x}{\z+1}\tsep \mem} \\
  \opStep\quad &
  \tuple{\Assign{\x}{\z+1}\tsep \mem\mUpdate{\y}{2}} \\
  \opStep\quad &
  \tuple{\Done\tsep \mem\mUpdate{\y}{2}\mUpdate{\x}{1}}.
\end{align*}
$$
## T3: Four flavors of program proofs (40 pts)

### (a) 
Show that the following triple is valid by applying the definition of valid Hoare triple and arguing in terms of the operational semantics.

![[2. Overview - Definition 2-10 Foundational Judgement for Toy Triples.png]]

**Triple**: $\Triple{0 < \x \And 0 \leq \y}{\Assign{\y}{\y + \x}\Seq\Assign{\x}{\y + \y}}{0 < \x}$

**Proof**: Let $\mem$ be an arbitrary memory such that $\mem \Satisfies 0 < \x \And 0 \leq \y$.

By operational semantics:
1. $\tuple{\Assign{\y}{\y + \x}\Seq\Assign{\x}{\y + \y}, \mem}$
2. $\opStep \tuple{\Assign{\x}{\y + \y}, \mem\mUpdate{\y} {\y + \x}}$
3. $\opStep \tuple{\Done, \mem\mUpdate{\y}{\y + \x}\mUpdate{\x}{\y + \y}}$

Let $\mem' = \mem\mUpdate{\y}{\y + \x}\mUpdate{\x}{\y + \y}$.

We have $\mem'(\x) = 2*(\mem(\y) + \mem(\x))$. 

Since $\mem(\x) > 0$ and $\mem(\y) \geq 0$, we have $\mem(\y) + \mem(\x) > 0$.
Therefore, 
$$
\begin{align}
\mem'(\x) = 2(\mem(\y) + \mem(\x)) > 0  \\
\dots

\end{align}
$$

Thus $\mem' \Satisfies 0 < \x$, proving the triple is valid.

### (b)
![[2. Overview - Definition 2-11 Toy Program Logic.png|500]]

**Triple**: 
$$\Triple{\y \teq 0}{\Ite{\x \teq 0}{\Skip}{\Assign{\y}{\x + \x}}\Seq\Assign{\z}{\y + \x}}{\z \teq 3 \cdot \x}
$$

The proof tree:
$$
\begin{prooftree}
\AxiomC{}
\AxiomC{}
\RightLabel{skip}
\UnaryInfC{$\provable \Triple{\y \teq 0 \wedge x \teq 0}{\Skip}{\y \teq 0 \wedge x \teq 0}$}
\AxiomC{$(\y \teq 0 \wedge x \BinaryInfCteq 0) \Entails (\y + \x \teq 3 \cdot \x)$}
\RightLabel{consequence}
\TrinaryInfC{$\provable \Triple{\y \teq 0 \wedge x \teq 0}{\Skip}{\y + \x \teq 3 \cdot \x}$}
\AxiomC{$\y \teq 0 \wedge \Neg(\x \teq 0) \Entails (\x + \x + \x \teq 3 \cdot \x)$}
\AxiomC{}
\RightLabel{assign}
\UnaryInfC{$\provable \Triple{\x + \x + \x \teq 3 \cdot \x}{\Assign{\y}{\x + \x}}{\y + \x \teq 3 \cdot \x}$}
\AxiomC{$(\y + \x \teq 3 \cdot \x) \Entails (\y + \x \teq 3 \cdot \x)$}
\RightLabel{consequence}
\TrinaryInfC{$\provable \Triple{\y \teq 0 \wedge \Neg(\x \teq 0)}{\Assign{\y}{\x + \x}}{\y + \x \teq 3 \cdot \x}$}
\RightLabel{conditional}
\BinaryInfC{$\provable \Triple{\y \teq 0}{\Ite{\x \teq 0}{\Skip}{\Assign{\y}{\x + \x}}}{\y + \x \teq 3 \cdot \x}$}
\AxiomC{}
\RightLabel{assign}
\UnaryInfC{$\provable \Triple{\y + \x \teq 3 \cdot \x}{\Assign{\z}{\y + \x}}{\z \teq 3 \cdot \x}$}
\RightLabel{sequence}
\BinaryInfC{$\provable \Triple{\y \teq 0}{\Ite{\x \teq 0}{\Skip}{\Assign{\y}{\x + \x}}\Seq\Assign{\z}{\y + \x}}{\z \teq 3 \cdot \x}$}
\end{prooftree}
$$
### (c) Analysis of modified triple
Is there a precondition F and a memory m with m |= F and m ̸|= y == 0 such that |= {{ y == 0 }} if ( F ) {skip} else {y := x + x} ; z := y + x {{ z == 3 · x }} holds?

No, there is no such precondition $F$ and memory $\mem$.

counter example...

**Justification**: For the triple to be valid with precondition $\y \teq 0$, we need that whenever $\mem \Satisfies \y \teq 0$, after executing the command, the postcondition $\z \teq 3 \cdot \x$ holds.

The issue is that if we use a Boolean expression $F$ as the condition in the if-statement instead of $\x \teq 0$, the correctness depends on the relationship between $F$ and the value of $\x$. 

For the postcondition to hold:
- When $F$ is true (skip branch): we need $\y + \x = 3 \cdot \x$, which requires $\y = 2 \cdot \x$
- When $F$ is false (else branch): after $\y := \x + \x$, we get $\z = 2\x + \x = 3\x$ ✓

Since we require $\y \teq 0$ as precondition, the skip branch requires $0 + \x = 3 \cdot \x$, which means $\x = 0$. So $F$ must be true exactly when $\x = 0$ for all memories satisfying the precondition. But if $\mem \Satisfies F$ and $\mem \not\Satisfies \y \teq 0$, then we cannot guarantee the postcondition.

### (d) Proof outline

```
{{ x == 2 ∗ y ∧ y == 2 ∗ x ∧ A == 0 ∧ B == 4 ∗ x }}
// ???
// {{ x = 0 & y = 0 & A = 0 & B = 0 }}
{{ (x > y ==> (x == B ∧ x - y == A)) ∧ (x <= y ==> (y - x == B ∧ y == A)) }}
{{ (x > y ==> (x - y + y == B ∧ x - y == A)) ∧ (x <= y ==> (y - x == B ∧ y - x + x == A)) }}
if ( x > y ) {
  {{ x - y + y == B ∧ x - y == A }}
  z := x - y;
  {{ z + y == B ∧ z == A }}
  x := z + y;
  {{ x == B ∧ z == A }}
  y := z;
  {{ x == B ∧ y == A }}
} else {
  {{ y - x == B ∧ y - x + x == A }}
  z := y - x;
  {{ z == B ∧ z + x == A }}
  y := z + x;
  {{ z == B ∧ y == A }}
  x := z;
  {{ x == B ∧ y == A }}
}
{{ x == B ∧ y == A }}
```

### (e) Weakest precondition

```chip
{ x = B & y = A & 0 < x & 0 < y }
if ( x > y ) ->
x := x - y
[] x <= y ->
y := y - x
fi
{ x <= B & y <= A }
```

{{ x == B ∧ y == A ∧ 0 < x ∧ 0 < y }}
if ( x > y ) {
	x := x − y
} else {
	y := y − x
}
{{ x ≤ B ∧ y ≤ A }}

---

{{ x == B ∧ y == A ∧ 0 < x ∧ 0 < y }} // F
{{ (x > y ==> (x − y ≤ B ∧ y ≤ A)) ∧ (x ≤ y ==> (x ≤ B ∧ y − x ≤ A)) }} // F'
if ( x > y ) {
	{{ x − y ≤ B ∧ y ≤ A }}
	x := x − y
	{{ x ≤ B ∧ y ≤ A }}
} else {
	{{ x ≤ B ∧ y − x ≤ A }}
	y := y − x
	{{ x ≤ B ∧ y ≤ A }}
}
{{ x ≤ B ∧ y ≤ A }}

proof $F' \Entails F$
## T4: Strongest Postconditions (40 pts)

