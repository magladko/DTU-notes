> [!summary] 
> • Key focus: Automated reasoning in many-sorted first-order predicate logic (FOL)
> 
> • Verification framework:
>   - Program verification → verification condition validity
>   - Validity check → satisfiability problem (valid iff negation unsatisfiable)
> 
> • FOL characteristics:
>   - Signature defines allowed symbols
>   - Structures provide symbol interpretation
>   - Must support program language expressions
> 
> • SMT (Satisfiability Modulo Theories):
>   - Checks formula satisfiability under axioms
>   - Complexity varies by theory (e.g., linear integer arithmetic: decidable, nonlinear: undecidable)
>   - Custom theories via uninterpreted functions + axioms
>   - Solvers use heuristics even for undecidable theories


| Metavariable             | Meaning                                 |
| ------------------------ | --------------------------------------- |
| $n, m$                   | natural numbers taken from $\mathbb{N}$ |
| $\Sigma$                 | signature                               |
| $f$                      | function symbol                         |
| $R$                      | relation symbol                         |
| $c$                      | constant symbol                         |
| $\mathfrak{A}$           | structure                               |
| $A$                      | universe of $\mathfrak{A}$              |
| $\mathfrak{R}$           | the structure of standard arithmetic    |
| $x, y, z$                | variables                               |
| $t$                      | term                                    |
| $F, G, H$                | formulae                                |
| $\mathfrak{v}$           | variable assignment                     |
| $\mathfrak{I}$           | interpretation                          |
| $\mathbf{AX}$            | axiom system                            |
| $\mathbf{T}, \mathbf{S}$ | sorts                                   |

## Key Concepts

### Foundational Elements
- Program verification can be reduced to solving an *entailment problem*: 
  $\ff \Entails \fg$
- Entailment means all $\mem$ that satisfy $\ff$ also satisfy $\fg$

### First-Order Predicate Logic (FOL)
- Base framework that generalizes simpler formulae
- Needed because propositional logic alone is insufficient for program verification
- Must support:
  - Integer-valued variables
  - Numeric constants
  - Arithmetic operations
  - Comparisons
  - Multiple types (lists, trees, maps, arrays)
  - Quantifiers

### Structures & Signatures

> [!info] Signature Definition
> A *signature* is a pair $\Sigma = \tuple{\mathbf{Fun}, \mathbf{Rel}}$, where:
> - $\mathbf{Fun}$ is a set of function symbols
> - $\mathbf{Rel}$ is a set of relation symbols
> - Each symbol has an *arity* (number of parameters)

### Terms & Formulae
- Terms are expressions composed from:
  - Variables
  - Constant symbols 
  - Function symbols
- Formulae combine:
  - Relations between terms
  - Logical connectives
  - Quantifiers

## Important Concepts for Verification

### SMT (Satisfiability Modulo Theories)
1. What is SMT?
   - Checks if formula is satisfiable under specific theories
   - Can encode verification problems into SMT
   - Different theories have different decidability properties

2. Common Theories:
   - EQ (Theory of Equality)
   - EUF (Equality with Uninterpreted Functions)
   - Arithmetic Theories (Real, Integer, Linear)
   - Arrays

> [!tip] Exam Tip
> Understanding which theories are decidable and which are not is important:
> - Real arithmetic: **Decidable**
> - Peano arithmetic: **Undecidable**
> - Presburger arithmetic (no multiplication): **Decidable**

### Working with Quantifiers
- Universal quantifiers ($\forall$) common in axioms
- E-matching used to control quantifier instantiation
- Patterns help guide the SMT solver
- Poor pattern choice can lead to non-termination

## Practical Considerations

### SMT Solver Usage
1. Input format: SMT-LIB
   ```lisp
   (declare-const x Int)
   (assert (> x 0))
   (check-sat)
   ```
2. Common Results:
	- sat (satisfiable)
    - unsat (unsatisfiable)
    - unknown (cannot determine)

>[!warning] Common Pitfalls
>
> - Non-termination with quantifiers
> - Memory exhaustion in matching loops
> - Using wrong theories for the problem

## Exam Tips

- Focus on understanding:
    1. When to use which theory
    2. Decidability implications
    3. Pattern selection for quantifiers
    4. Translation of verification problems to SMT
- Be prepared to explain soundness and completeness
- Practice writing and analyzing simple SMT-LIB code

# Important Definitions Reference

## Foundational Definitions

### Variables
$\Vars \defqeq \Set{\x,\y,\z, \ldots}$ is an arbitrary, but fixed, finite set of *variable names*.

### Signatures
A *signature* is a pair $\Signature = \tuple{\Functions, \Relations}$, where:
- $\Functions$ is a set of *function symbols* 
- $\Relations$ is a set of *relation symbols*
- $\Functions \cap \Relations \eq \emptyset$
- Every symbol has an *arity* $n \geq 0$
- Function symbols of arity 0 are called *constant symbols*
- Relations must have arity $n \geq 1$

### Structures
A $\Signature$-*structure* $\Structure \eq \tuple{\Universe, \Interpreted{\fun}, \Interpreted{\rel}, \ldots}$ consists of:
- A non-empty set $\Universe$ called the *universe* (or carrier)
- An $n$-ary function $\Interpreted{\fun}\colon \Universe^n \to \Universe$ for every function symbol
- An $n$-ary relation $\Interpreted{\rel} \subseteq \Universe^n$ for every relation symbol

### Terms 
The set of $\Signature$-*terms* $\Term$ is given by the grammar:
$$
\begin{aligned}
\Term \qq{\EBNF} & \x & \text{(variable)} \\
\qq{|} & \const & \text{(constant)} \\
\qq{|} & \fun(\Term_1, \ldots, \Term_n), & \text{(function application)}
\end{aligned}
$$
A term is *ground* if it contains no variables.

### Formulae
$\Signature$-*formulae* are composed of:
- Relations between $\Signature$-terms
- Logical connectives ($\Neg, \And, \Or, \Implies, \Equivalent$)
- Quantifiers ($\Exists, \Forall$)

### Interpretations
A *$\Signature$-interpretation* $\Interpretation \eq \tuple{\Structure,\VarAssignment}$ consists of:
- A $\Signature$-structure $\Structure$ with universe $\Universe$
- A function $\VarAssignment\colon \Vars \to \Universe$ assigning values to variables

## SMT-Related Definitions

### Patterns
A *pattern* for $\Forall \xs\qdot \ff$ is a term $p$ where:
- $p$ contains all quantified variables in $\xs$
- $p$ contains at least one non-constant *uninterpreted* function
- $p$ contains at most constant *interpreted* functions

### E-Matching
A sequence of terms $\ees$ *E-matches* a pattern $p$ over variables $\xs$ with respect to formula $\fg$ if:
- There exists a term $\Term$ in $\fg$ such that:
  $\fg \qq{\Entails} \Term \teq p\subst{\xs}{\ees}$

### Satisfiability Modulo Theories
A $\Signature$-formula $\ff$ is *satisfiable modulo the theory of* $\AX$ if:
- There exists a $\Signature$-interpretation $\Interpretation$ where:
  $\Interpretation \Satisfies \AX \qand \Interpretation \Satisfies \ff$

### Validity Modulo Theories
A $\Signature$-formula $\ff$ is *valid modulo the theory of* $\AX$ if:
- For every $\Signature$-interpretation $\Interpretation$:
  $\Interpretation \Satisfies \AX \qimplies \Interpretation \Satisfies \ff$

### Entailment Modulo Theories
A formula $\ff$ *entails* formula $\fg$ modulo theory $\AX$ if:
- For every interpretation $\Interpretation$ with $\Interpretation \Satisfies \AX$:
  $\Interpretation \Satisfies \ff \qimplies \Interpretation \Satisfies \fg$
