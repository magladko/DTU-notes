## [Toy Floyd-Hoare Triples (syntax+semantics)](https://pv24.cmath.eu/01-overview.html#toy-floyd-hoare-triples)

## Summary

> [!summary] 
> • Floyd-Hoare triples: $\Triple{\Pre}{\cc}{\Post}$ - relationship between pre/post conditions and code
> 
> • Two judgement types:
>   - Foundational ($\models$): based on operational semantics, meaningful but complex
>   - Deductive ($\JudgeSyn$): based on inference rules, practical through proof trees
>  
> • Key properties:
>   - Soundness: provable → valid (required)
>   - Completeness: valid → provable (ideal)
>
> • Automation approach:
>   - Weakest precondition calculation
>   - Verification condition checking
>   - Automated reasoning tools

In this chapter, we took a tour through the main concepts of program
verification, how to justify why verification results are meaningful,
and the main steps for automating verification. The key take-aways are:

-  We specify program properties as **Floyd-Hoare triples** of the form $\Triple{\Pre}{\cc}{\Post}$, where $\Pre$ is a **precondition**, $\cc$ is an **executable piece of code**, and $\Post$ is a **postcondition**. Intuitively, a triple states that, whenever $\Pre$ holds before $\cc$, then $\Post$ holds after $\cc$.
-  Program verification then refers to the task of judging triple. We introduced two notions for making such judgements.
-  We defined a ***foundational judgement*** $\models \Triple{\Pre}{\cc}{\Post}$ (read: **the triple is *valid***), which formalizes the above intuition in terms of an operational semantics, i.e. a mathematical model of the possible executions of $\cc$. Semantic judgements represent meaningful program properties but are hard to prove.
-  We defined a ***deductive judgement*** $\JudgeSyn \Triple{\Pre}{\cc}{\Post}$, which judges triples as *provable* based on a program logic, i.e. a set of inference rules. The main advantage of this approach is that we can prove triples by constructing proof trees or proof outlines by systematically applying fairly syntactic rules.
-  To ensure that **deductive judgements** are meaningful, we **connect** them to **foundational judgements.** In particular, our program logics *must* be ***sound*, i.e. every provable triple must also be valid**. 
-  Ideally, our program logic should also be ***complete*, i.e. every valid triple should be provable**. We proved completeness by studying the ***weakest precondition*** of a command and a postcondition, i.e. a formula satisfied by all memories from which execution of the commands terminates in memories satisfying the postcondition.
-  To automate program verification, we reduce it to checking a ***verification condition***, e.g. whether a given precondition entails the weakest precondition. In many cases, we can employ tools for automated reasoning about logic to discharge verification conditions.


### Toy Memories
![[Toy Memories Definition.png]]
### Updated Memory
![[Updated memory.png]]
### Functions and expressions over memory
![[fn over memory.png]]

### Toy Configurations and Final Configurations
![[Toy Configurations and Final Configurations.png]]

### Execution Relation
![[Execution Relation.png]]
### Inference rules defining execution relation
![[inference rules - execution relation.png]]

### Reachable computation ($\Rightarrow^*$)
![[reachable computation.png]]
### Foundational Judgement for Toy Triples
![[Foundational Judgement for Toy Triples.png]]
## [Program Logics](https://pv24.cmath.eu/01-overview.html#program-logics)
>[!hint] $\vdash$ Deductive judgement **vs** $\models$ Foundational judgements
>- $\vdash$ ***provable***
>- $\models$ ***valid***

### Toy Program Logic (triples)
![[Toy Program Logic (triples.png]]
### Proof trees
![[Proof trees.png]]
#### Theorem - Characterization of Proof Trees
![[characterization of proof trees theorem.png]]
### Entailment Relationship for Toy Logical Formulae ($F \models G$)
![[entailment relationship formulae.png]]

### Substitution $F[\mathtt{x}:=a]$ (as part of assignment encoding)

![[substitution lemmas.png]]

### Proof trees vs Proof outlines
$$
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\JudgeSyn \Triple{\y \teq 0 \And \x \teq 0}{\Skip}{\y \teq 0 \And \x \teq 0}$}
\noLine
\UnaryInfC{$\y \teq 0 \And \x \teq 0 \Entails \y \teq 0 \And \x \teq 0$}
\noLine
\UnaryInfC{$\y \teq 0 \And \x \teq 0 \Entails \y+\x+\y \teq 5*\x$}
\UnaryInfC{$\JudgeSyn \Triple{\y \teq 0 \And \x \teq 0}{\Skip}{\y+\x+\y \teq 5*\x}$}
\AxiomC{}
\UnaryInfC{$\JudgeSyn \Triple{\x+\x+\x+\x+\x \teq 5 * \x}{\Assign{\y}{\x+\x}}{\y+\x+\y \teq 5*\x}$}
\noLine
\UnaryInfC{$\y \teq 0 \And \Neg(\x \teq 0) \Entails \x+\x+\x+\x+\x \teq 5 * \x$}
\noLine
\UnaryInfC{$\y+\x+\y \teq 5*\x \Entails \y+\x+\y \teq 5*\x$}
\UnaryInfC{$\JudgeSyn \Triple{\y \teq 0 \And \Neg(\x \teq 0)}{\Assign{\y}{\x+\x}}{\y+\x+\y \teq 5*\x}$}
\BinaryInfC{$\JudgeSyn \Triple{\y \teq 0}{\Ite{\x \teq 0}{\Skip}{\Assign{\y}{\x+\x}}}{\y+\x+\y \teq 5*\x}$}
\end{prooftree}
$$

```
{{ y == 0 }} // precondition
if (x == 0) {
  {{ y == 0 ∧ x == 0 }}
  skip
  {{ y == 0 ∧ x == 0 }}
  {{ y + x + y == 5 * x }}
} else {
  {{ y == 0 ∧ ¬(x == 0) }}
  {{ x+x + x + x+x == 5 * x }}
  y := x + x
  {{ y + x + y == 5 * x }}
};
{{ y + x + y == 5 * x }}
z := y + x + y
{{ z == 5 * x }} // postcondition
```

#### Annotated commands
![[annotated commands def.png]]
#### Fully annotated commands
![[fully annotated commands.png]]

## Soundness vs Completeness

### Soundness ($\quad \vdash \quad \rightarrow \quad \models \quad$)

>[!definition]
>$$\vdash \triple{\F}{C}{G} \text{ implies } \models \triple{F}{C}{G}$$

### Completeness ($\quad \models \quad \rightarrow \quad \vdash \quad$)

>[!definition]
>$$\models \triple{\F}{C}{G} \text{ implies } \vdash \triple{F}{C}{G}$$

### Theorem - Toy Program logic soundness
![[toy program logic soundess theorem.png]]

### Completeness proving (weakest precondition)

![[weakest precondition def.png]]
![[weakest precondition example.png]]

![[wp example 2.png]]

### Theorem - **wp** provability
>[!Theorem]
>$$\vdash \Triple{\Wp{C}{G}}{C}{G}$$

proof...

![[theorem wp.png]]

### Characterization of weakest precondition
![[characterization of wp.png]]
>[!note] iff F entails weakest precondition

## Automation

Based on theorem **2.6** we just prove the right part by negation:
>[!note] 
>$$F \quad \land \quad \lnot \Wp{C}{G}$$
> If **unsat** => the triple is **valid**
