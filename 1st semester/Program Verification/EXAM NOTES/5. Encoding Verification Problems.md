> [!summary] 
> • Approach to new features:
>   - Formalize semantics
>   - Develop sound proof rules
>   - Create verification conditions
>   - Encode into existing IVL
> 
> • Benefits:
>   - Leverage existing automation
>   - Inherit supported features
>   - Sound verification via IVL encoding
> 
> • Implementation aspects:
>   - Complex program transformations needed
>   - Examples: conditionals, assignments, scoped variables
>   - DSA transformations
>   - Declaration reorganization

# Encoding Verification Problems - Exam Notes

## 1. Core Components

### IVL₀ to IVL₁ Relationship
> [!info] Core Concept
> IVL₁ extends IVL₀ by adding common programming features. All IVL₁ features are encoded back to IVL₀ for verification.

#### IVL₀ Base Features
- First-order logic formulae
- Basic commands:
  - `Assert{f}`
  - `Assume{f}`
  - Sequential composition `c₁;c₂`
  - Nondeterministic choice `{c₁} [] {c₂}`

#### IVL₁ Extensions and Their Encodings

1. **Conditionals** (`if b then c₁ else c₂`)
   ```
   Encoding: {Assume{b};c₁} [] {Assume{¬b};c₂}
   ```
   > [!important] Verification Condition:
   > $$ wp(if~b~then~c_1~else~c_2)(Post) \equiv (b \implies wp(c_1)(Post)) \land (\neg b \implies wp(c_2)(Post)) $$

2. **Assignments** (`x := e`)
   - Two approaches:
     a. Substitution-based (elegant but can cause exponential growth)
     b. DSA-based (more efficient)
   > [!warning] Key Challenge
   > Substitution can lead to exponential growth in verification conditions:
   > ```
   > {x == ((start + end)/2) * ((start + end)/2) * ((start + end)/2)}
   > res := (start + end)/2
   > {x == res * res * res}
   > ```

3. **Parallel Assignments** (`x₁,...,xₙ := e₁,...,eₙ`)
   - Encoding uses temporary variables to preserve values:
   ```
   x₁':= x₁;...;xₙ':= xₙ;
   x₁:= e₁[x₁/x₁']...[xₙ/xₙ'];
   ...
   xₙ:= eₙ[x₁/x₁']...[xₙ/xₙ']
   ```

4. **Variable Declarations and Scope**
   a. **Basic Declaration** (`var x:T`)
      - Add to preamble
      - Replace with havoc operation if re-declaration
   
   b. **Initialized Declaration** (`var x:T := e`)
      - Add to preamble
      - Replace with assignment `x := e`
   
   c. **Block Scope** (`begin c end`)
      ```mermaid
      graph TD
        A[Enter Block] -->|Save variables| B[Execute Block Body]
        B --> |Restore variables| C[Exit Block]
      ```
      
      Encoding:
      ```
      var y₁,...,yₙ:T₁,...,Tₙ := x₁,...,xₙ;  // save
      c;                                      // execute
      x₁,...,xₙ := y₁,...,yₙ                 // restore
      ```

### Dynamic Single Assignment (DSA)

> [!important] DSA Properties
> - Every assignment on any execution path assigns to a fresh variable
> - Used to avoid variable value conflicts
> - Enables efficient verification condition generation

Example transformation:
```
Original:
x := 0;
{
  x := (y+z)*y;
  x := 7
} [] {
  x := -12
};
y := x

DSA Form:
x₁ := 0;
{
  x₂ := (y₁+z₁)*y₁;
  x₃ := 7
} [] {
  x₂ := -12;
  x₃ := x₂
};
y₂ := x₃
```

## 2. Exam Tips

### Question Patterns and Approaches
1. **Encoding Questions**
   > [!example] Standard Flow
   > 1. Write operational semantics
   > 2. Define verification condition
   > 3. Propose IVL₀ encoding
   > 4. Prove soundness
   
2. **DSA Transformation**
   - Focus on path-based analysis
   - Pay attention to variable versions in different branches
   - Remember to synchronize variables after choice constructs

3. **Soundness Proofs**
   - Show: If encoding verifies, then original verification condition holds
   - Use weakest precondition calculations
   - Consider all possible execution paths

### Common Pitfalls
> [!warning] Watch Out For
> - Missing cases in operational semantics
> - Incorrect variable scoping in blocks
> - Forgetting to synchronize variables after choices in DSA
> - Not handling fresh variables properly

## 3. Mathematical Reference

### Metavariables Reference

| Metavariable  | Meaning                               |
| ------------- | ------------------------------------- |
| $n,m$         | natural numbers                       |
| $k,l$         | integers                              |
| $\x,\y,\z$    | variables                             |
| $\xs,\ys,\zs$ | sequences of variables                |
| $\xts$        | sequence of variables and their types |
| $\cc$         | commands                              |
| $\fun$        | function symbols                      |
| $\TT$, $\TTS$ | types (sorts)                         |
| $\ff,\fg,\fh$ | FOL formulae                          |
| $\mem$        | memories (program states)             |

> [!note] Mathematical Notation Conventions
> - Variables use specific notation (e.g., $\x$ instead of x)
> - Type variables use double-struck capital letters ($\TT$ for types)
> - Command variables use proper formatting ($\cc$ for commands)
> - Sequences use overline notation ($\xs$ for sequence of variables)

### Key Definitions

#### Definition 1: Dynamic Single Assignment Form
A command $$c$$ is in DSA iff for every path in $$Paths(c)$$ of form:
$$ c_1 \ldots c_n \texttt{ Assign }\{x\}\{e\} $$
$$x$$ is fresh:
$$ x \notin \VarsOf{e} \cup \bigcup_{i=1}^n \VarsOf{c_i} $$

#### Definition 2: Weakest Precondition for Havoc
$$ wp(\text{havoc}~x)\{Post\} \equiv \forall x:T \cdot Post $$

### Inference Rules

1. **Assignment Rule**
$$\begin{prooftree}
\AxiomC{}
\RightLabel{par-assign}
\UnaryInfC{$\JudgeSyn \Triple{\Post\Subst{\Sequence{\x}}{\Sequence{\ee}}}{\Assign{\Sequence{\x}}{\Sequence{\ee}}}{\Post}$}
\end{prooftree}$$

2. **Block Rule**
$$\begin{prooftree}
\AxiomC{$\JudgeSyn \Triple{\Pre}{\cc}{\Post}$}
\AxiomC{$\Declared(\cc) \cap \VarsOf{\Post} \eq \emptyset$}
\RightLabel{block}
\BinaryInfC{$\JudgeSyn \Triple{\Pre}{\BlockBegin~\cc~\BlockEnd}{\Post}$}
\end{prooftree}$$

3. **Parallel Assignment Rule**
$$\begin{prooftree}
\AxiomC{}
\RightLabel{par-assign}
\UnaryInfC{$\JudgeSyn \Triple{\Post\Subst{\Sequence{\x}}{\Sequence{\ee}}}{\Assign{\Sequence{\x}}{\Sequence{\ee}}}{\Post}$}
\end{prooftree}$$

4. **Conditional Rule**

$$
\begin{prooftree}
\AxiomC{$\JudgeSyn \Triple{F \wedge b}{\cc_1}{G}$}
\AxiomC{$\JudgeSyn \Triple{F \wedge \neg b}{\cc_2}{G}$}
\RightLabel{choice}
\BinaryInfC{$\JudgeSyn \Triple{F}{\ite{b}{\cc_1}{\cc_2}}{G}$}
\end{prooftree}
$$
### Operational Semantics Rules

1. **Assignment**
$$ \frac{}{\langle x := e, mem \rangle \rightarrow \langle \text{Done}, mem[x \mapsto [\![ e ]\!](mem)] \rangle} $$
2. Parallel Assignment
$$\begin{prooftree}
\AxiomC{$\tforall i \in \Set{1,\ldots,i}, \quad \evalE{\ee_i}(\mem) \eq \vv_i$}
\RightLabel{par-assign}
\UnaryInfC{$\tuple{\Assign{\x_1,\ldots,\x_n}{\ee_1,\ldots,\ee_n}\tsep \mem} \qopStep \tuple{\confTerm, \mem\iUpdate{\x_1}{\vv_1}\ldots\iUpdate{\x_n}{\vv_n}}$}
\end{prooftree}$$

3. **Conditional Execution**
$$\begin{prooftree}
\AxiomC{$\mem \Satisfies \bb$}
\RightLabel{ite-true}
\UnaryInfC{$\tuple{\Ite{\bb}{\cc_1}{\cc_2}\tsep \mem} \qopStep \tuple{\cc_1, \mem}$}
\end{prooftree}$$
$$\begin{prooftree}
\AxiomC{$\mem \NotSatisfies \bb$}
\RightLabel{ite-false}
\UnaryInfC{$\tuple{\Ite{\bb}{\cc_1}{\cc_2}, \mem} \qopStep \tuple{\cc_2, \mem}$}
\end{prooftree}$$


