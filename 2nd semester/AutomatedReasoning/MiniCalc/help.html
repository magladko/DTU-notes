<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>MiniCalc Help</title></head><body> <style>@import "https://fonts.cdnfonts.com/css/neo-sans-std";*{box-sizing:border-box}html{height:100vh;--vscode-editorSuggestWidget-background:white}body{height:100vh;min-height:0;grid-template-rows:auto 1fr;margin:0;display:grid;position:relative}nav{text-align:center;background-color:#030f4f;justify-content:space-between;align-items:center;margin:0;padding:7px 10px;font-family:Neo Sans Std;font-size:16px;display:flex}nav p{color:#fff;margin:0;padding:0}nav g{color:#fff;margin:0;padding-top:3px;padding-bottom:3px}nav p a{color:#000;width:100%;background-color:#fff;border-radius:1px;padding:3px 6px;text-decoration:none;display:block}#root{min-height:0}#root>div{height:100%;grid-template-columns:1fr 1fr;gap:10px;padding:5px;display:grid}@media screen and (max-width:990px){#root>div{grid-template-rows:50% auto;grid-template-columns:1fr}}section{text-align:left;width:auto;margin:0;padding:0 20px;overflow:auto}#output{font-family:monospace;font-size:14px;line-height:19px;overflow:auto}pre{text-align:left;background:#dadada;margin:0;padding:20px}section pre{margin:10px}.code-editor{height:100%;position:relative}.code-editor>div{height:100%;position:absolute;inset:0}td{padding-right:40px}th{padding-right:10px}</style> <nav> <p>MiniCalc</p> <p><a href="javaScript:void(0);" id="example-btn">Copy Example Proofs to Clipboard</a></p> <p>Version 1.0</p> </nav> <section> <h1>What is this?</h1> <p> MiniCalc is a one-sided sequent calculus embedded in the logic of the Isabelle proof assistant. Sequents are represented as lists of formulas. Since the calculus is one-sided, it has rules not only for each connective, but also for the negation of each connective. </p> <p> This page explains how to use MiniCalc to prove formulas in first-order logic. The reader is assumed to know how proofs in sequent calculus work, see e.g. System G in <a href="https://link.springer.com/book/10.1007/978-1-4471-4129-7" target="_blank" rel="noopener noreferrer"><em>Mathematical Logic for Computer Science</em> by Mordechai (Moti) Ben-Ari</a>. </p> <p> If you are already familiar with MiniCalc, or if you want to try it out immediately, click <a href="#examples">here</a> to jump to some example proofs. </p> <h1>Copyright information</h1> <p> Copyright &copy; 2024 Oliver Emil Bøving, Asta Halkjær From, Frederik Krogsdal Jacobsen, Alexander Birch Jensen, Emmanuel André Ryom, Anders Schlichtkrull & Jørgen Villadsen </p> <p> This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p> <p> Source code from other authors is used and the license agreements may be viewed <a href="licensing.html" target="_blank" rel="noopener noreferrer">here</a>. </p> <h1>How the result can be formally verified in Isabelle</h1> <p> If the <a href="https://isabelle.in.tum.de/" target="_blank" rel="noopener noreferrer">Isabelle</a> proof assistant is installed then the MiniCalc proof can be verified. When the proof is finished simply click on "Copy Result to Clipboard" in order to copy the proof to the clipboard in a format to be pasted into Isabelle. MiniCalc is embedded in such a way that formulas that we want to prove in MiniCalc are defined as lemmas in Isabelle, which verifies the MiniCalc proof of the formula. </p> <p> You will need the files <a href="MainProof.thy" target="_blank" rel="noopener noreferrer"><code>MainProof.thy</code></a> and <a href="MiniCalc.thy" target="_blank" rel="noopener noreferrer"><code>MiniCalc.thy</code></a>, which define the calculus. To use MiniCalc, your Isabelle theory must import MiniCalc using the following line, which should be placed at the top of your file: </p><blockquote> <code> theory Example imports MiniCalc begin </code> </blockquote> <p></p> <p> All files must be in the same directory. The name of the theory ("Example" above) must be the same as the name of the file containing it, except the extension ".thy", which should not be included. </p> <p> At the end of the file, you must add a line containing the keyword <code>end</code> to match the keyword <code>begin</code> above. </p> <p> Isabelle will complain and highlight some lines of your file in red if there is some mistake, such as forgetting a matching keyword or bracket. Isabelle will also highlight any proofs that it cannot verify in red to let you know there is an error. </p> <p> Isabelle continuously checks whether your proofs are correct, so there is no "compile" or "commit" step like you might be used to from programming. </p> <h1>How to write a lemma in MiniCalc</h1> <p> Before we can start to prove things using MiniCalc, we need to know how to express the formulas we want to prove. </p> <p> While it is possible to write formulas and proofs directly into Isabelle, MiniCalc makes this process much easier. MiniCalc allows you to write multiple proofs in the same window by separating them with minuses (<code>-</code>) or hashes (<code>#</code>). MiniCalc has an integrated prover that adds a warning if it finds a mistake in your proof, but for formal verification you must still copy and paste the proofs into Isabelle. An optional comment in quotes may follow either of these symbols, and will then be included in the generated MiniCalc Isabelle proof text as either a piece of text (for minuses) or a section header (for hashes). It is also possible to insert comments delimited by <code>(*</code> and <code>*)</code> at any point, though these comments will not be included in the result. </p> <h2>Terms: functions, constants and variables</h2> <p> The syntax of MiniCalc consists of terms and formulas. A predicate must be applied to a list of terms, and we will begin by explaining how to write these, as they are simpler than the formulas. </p> <p> In MiniCalc, terms are either function applications, which consist of a function name and a list of terms to apply the function to, or variables, which are written as numbers for reasons that will be explained later. In MiniCalc, functions do not have names like we are used to from mathematics or programming, but are instead identified by a (natural) number. MiniCalc will automatically convert the function names we use into appropriate numbers. Names must start with a letter, but the rest of the name can contain numbers, underscores (_) and ticks ('). Functions are always applied to a list of arguments, which must also be terms. Lists are written using the syntax <code>[a, b, c]</code>. </p> <p> A constant may be represented as a function applied to no arguments, i.e. a function applied to the empty list of terms, which may be written as <code>[]</code> or simply omitted. </p> <p> Let's look at some examples. A constant may be written as <code>a</code>. The name <code>a</code> is completely arbitrary. A different constant could thus be written as <code>b</code>, and these two constants could be used in the same formula. Note that <code>a</code> and <code>A</code> are different constants, since the names are case sensitive. </p> <p> It is of course also possible to write functions which are not constants. As an example, consider the following expression: <code>f[a, b]</code>. This expression applies function <code>f</code>, which is a function with two arguments, to functions <code>a</code> and <code>b</code>, which are both constants since they do not take any arguments. To use the same function twice in a formula, just write the same name in both places. </p> <p> The variables in MiniCalc are meant to be used with the first-order quantifiers of the logic. We will thus return to variables when we introduce the quantifiers. </p> <p> Both constants (i.e. functions with no arguments) and variables are meant to represent values in some domain, while functions represent functions over the domain. The domain can be any non-empty set, e.g. the natural numbers or the lines in a program. </p> <h2>Formulas: predicates, logical connectives, and quantifiers</h2> <p> To state a lemma in MiniCalc we need to write a formula, which can be either a predicate or a number of subformulas connected by logical connectives and quantifiers. </p> <p> The basic building block of MiniCalc formulas are predicates, which take a list of terms as arguments, and are written by writing their names. Predicates represent mappings from the arguments of the predicate to truth values. Since the arguments are terms, we may think of predicates as mappings from domain values to truth values. Just like with functions, it is possible to define constant predicates (relative to the domain) by letting the list of arguments be the empty list or by omitting it. </p> <p> Like functions, predicates do not have names as such, but are instead identified by a number. Again, MiniCalc will automatically convert the predicate names we use into appropriate numbers. These names are completely separate from the names used to identify functions, so it is not an issue to have both a function and a predicate named e.g. <code>a</code>, though this may lead to some confusion. </p> <p> An interpretation in MiniCalc contains a domain of values, an environment mapping variables to elements of the domain, a mapping from the identifier of each function to a function (which might be a constant) over the domain, and a mapping from the identifier of each predicate to a predicate over the domain. The interpretation we choose determines the truth value of each of the predicates in a formula. Whatever domain we are currently working in is often called the universe because it contains everything that we might want to consider in our formulas. </p> <h3>Logical connectives</h3> <p> Formulas can be combined using logical connectives. All of these connectives are applied to two existing formulas except the negation operator, which is only applied to one. A list of the connectives available in MiniCalc can be found in the first part of the table below. We note that these connectives are more than enough to define any other connective one might want. Note also that the connectives are applied in the style of functional programming, i.e. by writing <code>Imp A B</code> and not by writing <code>Imp(A, B)</code>. </p> <table> <tr> <th>Name</th> <th>Usual symbol</th> <th>MiniCalc syntax</th> </tr> <tr> <td>Implication</td> <td>A &rarr; B</td> <td><code>Imp A B</code></td> </tr> <tr> <td>Disjunction</td> <td>A &or; B</td> <td><code>Dis A B</code></td> </tr> <tr> <td>Conjunction</td> <td>A &and; B</td> <td><code>Con A B</code></td> </tr> <tr> <td>Negation</td> <td>&not; A</td> <td><code>Neg A</code></td> </tr> <tr> <td>Universal quantification</td> <td>&forall; A</td> <td><code>Uni A</code></td> </tr> <tr> <td>Existential quantification</td> <td>&exist; A</td> <td><code>Exi A</code></td> </tr> </table> <p> Using these connectives and the syntax described above, we may write any formula of propositional logic as a lemma. A simple example is the formula P &rarr; P, which may be written as <code>Imp P P</code>. Notice that propositional variables are simply predicates with no arguments, i.e. predicates which are assigned a truth value independently of the domain used in the interpretation. The lemma &vdash; P &rarr; P (which means "P &rarr; P can be proved") can be written in MiniCalc by simply writing down the formula. </p> <p> If you write this into MiniCalc, it will give you an error saying that it expects a proof rule. Proof rules are the steps that you can instruct the MiniCalc system to take when proving a lemma. We will return to these shortly. </p> <h3>Quantifiers</h3> <p> To go from propositional logic to first-order logic, we now introduce first-order <em>quantifiers</em>, which are special operators that specify the quantity of elements in the domain that satisfy some formula. In the logic of MiniCalc, we have only two quantifiers, those being the universal and existential quantifiers. </p> <p> The universal quantifier is written using the symbol &forall; in usual notation, and it specifies that <em>all</em> elements of the domain satisfy the formula following the quantifier. </p> <p> The existential quantifier is written using the symbol &exist; in usual notation, and it specifies that <em>some</em> (i.e. at least one) element of the domain satisfies the formula following the quantifier. </p> <p> You have probably already seen these quantifiers in various other contexts. The quantifiers in MiniCalc are essentially the usual quantifiers known from mathematics, except the quantifiers in MiniCalc always quantify over the entire domain. It is thus not necessary to note which set we are quantifying over (by writing e.g. &forall; x &in; S for some set S), since this is implicitly known to be the entire domain. </p> <p> A quantifier <em>binds</em> a variable, which represents the elements of the domain that the quantifier specifies in the formula following the quantifier. In usual notation we might for example write &forall; x . P(x) to mean that some predicate P is true for all elements of the domain or &exist; x . &forall; y . P(x) &rarr; Q(y) to mean that there is some element of the domain, which we bind to the variable name x, for which it holds that, if the predicate P holds for that element, the predicate Q holds for all elements of the domain. </p> <p> In MiniCalc, we do not want to have to keep track of the names of variables, so instead of identifying variables by conventional names, we will identify them by numbers. The numbering system we use for variables is a bit complicated, since we need to keep track of the quantifier that binds each variable. To do this we use so-called <em>de Bruijn indices</em> to identify the variables. The idea is to number the variables "from the inside out" so that the variable with index 0 is always bound by the innermost quantifier, and so on. Using de Bruijn indices, the formula </p><blockquote> &forall; x . &forall; y . &forall; z . P(x) &rarr; Q(y) &rarr; R(z) </blockquote> is written <blockquote> &forall; &forall; &forall; (P(2) &rarr; Q(1) &rarr; R(0)) . </blockquote> <p></p> <p> Note that the same index may be used for different variables if we have multiple "branches" within the formula, just like how we may usually use the same variable name in several places as long as their scopes do not overlap. Consider for example the formula </p><blockquote> &exist; x . (&forall; y . P(y) &and; Q(x)) &rarr; (&forall; y . Q(x) &and; P(y)) </blockquote> which is written <blockquote> &exist; (&forall; (P(0) &and; Q(1))) &rarr; (&forall; (Q(1) &and; P(0))) </blockquote> using de Bruijn indices. <p></p> <p> As mentioned previously, the reason for using de Bruijn indices is that we don't want to keep track of variable names. One reason for this is that the semantics of the MiniCalc system depend on being able to identify variables. Recall that an interpretation in MiniCalc contains an environment which maps variables to elements of the domain. The environment changes whenever we encounter a quantifier, since the newly quantified variable must be added to the environment. If we had used usual variable names, we would have to keep track of all of the names that are currently defined to construct this mapping. Since we use de Bruijn indices to represent variables, we can simply increment the index of every existing variable by one to make room for the new variable as the new innermost variable with index 0. Once we leave the scope of a quantifier, the variable it binds no longer exists, we decrement the index of every other variable to make the new innermost variable return to index 0. The environment is then simply a mapping from the natural numbers to elements of the domain. </p> <p> Another benefit of using de Bruijn indices is that they make it very easy to identify equivalent formulas containing quantifiers. Consider for example the formulas &forall; x . P(x) and &forall; y . P(y). These formulas clearly have exactly the same meaning, but they are not syntactically identical, so we would need some rule that allows us to prove that they are equivalent. With de Bruijn indices however, both of these formulas are written &forall; P(0), so there is no need to introduce an additional rule to prove the equivalence between the formulas. This allows us to easily prove formulas such as (&forall; x . P(x)) &rarr; (&forall; y . P(y)). </p> <p> In the MiniCalc syntax, the universal quantification &forall; A is written <code>Uni A</code>, while the existential quantification &exist; A is written <code>Exi A</code>. </p> <p> The table above contains an overview of the logical connectives and quantifiers available in MiniCalc. </p> <h1>The rules of MiniCalc</h1> <p> Now that we know how to write lemmas in MiniCalc, we can begin attempting to prove them. MiniCalc is a sequent calculus, which means that each step of a MiniCalc proof consists of a number of formulas which must be derived by the following steps. One might consider the lemma itself as the "first step" of a proof, since it must be derived by the rest of the proof. Since the proof must eventually end, we end the proof with a special step which needs no further derivations to apply. </p> <p> MiniCalc is a one-sided sequent calculus, which means that any formulas we assume to be true to prove a set of formulas are added to the set itself as negated formulas. We may do this because it can be proven that a statement &Gamma; &vdash; &Delta; can be proven in a standard sequent calculus if and only if &vdash; &not; &Gamma;, &Delta; can be proven in the corresponding one-sided sequent calculus. </p> <p> This leads us to the first rule of MiniCalc, which in usual logic notation says that &vdash; P, &not; P, &Gamma; is true. Here and in the rest of the rules, &Gamma; represents any formulas that are part of the set, but which are not relevant to the rule in question. If we convert the one-sided statement &vdash; P, &not; P, &Gamma; back to a "normal" statement, it becomes obvious that the rule is true: &not; &Gamma;, P &vdash; P means "if we assume P is true (and possibly some other things), then P is true". The actual rule is slightly different, but has essentially the same meaning: </p><blockquote> <code>Basic: &Vdash; p # z if member (Neg p) z</code> </blockquote> This rule is called <code>Basic</code>, and it may be stated in words as "this step of the proof is true <em>if</em> the negation of the first formula asserted in this step of the proof is also one of the formulas asserted in this step of the proof". In this context, the symbol <code>#</code> simply separates the first element of the list of formulas from the rest of the formulas, which we arbitrarily call <code>z</code> (instead of &Gamma;, as we do in the usual logic notation). <p></p> <p> The <code>Basic</code> rule is the only rule that can end a proof, since all of the other rules depend on the derivations of other formulas. Note that the right hand side of the rule is not a MiniCalc formula, but a purely computational condition that can be proven by simply looking at the asserted formulas. Note also that this rule can only be used for the first formula, since <code>p</code> is explicitly the head of the list of formulas. We will return to the question of what to do if we want to use another formula at the end of this section. </p> <p> Since the <code>Basic</code> rule is the only rule that can end a proof, every other rule will be followed by a list of formulas which is the result of applying the rule to the previous list of formulas. We will see how this is done in more detail in the examples below. </p> <p> Another very simple, but very important rule is the double negation rule, which is named <code>NegNeg</code> in the MiniCalc system. In usual logic notation, this rule says that &vdash; &not; &not; P, &Gamma; if &vdash; P, &Gamma;, and essentially means that negation cancels itself. Here is the rule: </p><blockquote> <code>NegNeg: &Vdash; Neg (Neg p) # z if &Vdash; p # z</code> </blockquote> <p></p> <p> Before we look at the rules for proving formulas involving logical connectives, let's look at a final obvious rule called <code>Ext</code>. This rule says that to prove a number of formulas &vdash; A, B, C, &hellip;, you may instead prove any subset of the original formulas, in any order. The mentioned list of formulas could thus be replaced by e.g. &vdash; A, &vdash; C, B, A, or &vdash; B, C. Here is the rule: </p><blockquote> <code>Ext: &Vdash; y if &Vdash; z and ext y z</code> </blockquote> The keyword <code>and</code> means that both of the statements around it must be proven separately. The definition of the function <code>ext</code> is not important, but the following lemma about the function gives us an interpretation of its meaning: <blockquote> <code>ext y z &harr; set z &subseteq; set y</code> </blockquote> This rule will mostly be useful for moving formulas to the front of the list to fit the pattern of the <code>Basic</code> rule, and for removing any formulas we don't need. Sometimes it may also be necessary to use the rule to duplicate a formula. <p></p> <h2>&alpha;- and &beta;-rules</h2> <p> The rules we have seen so far do not tell us anything about how to handle the logical connectives, but there are of course also rules to prove formulas involving them. We will see that these rules can be divided into two categories depending on the number of formulas that must be derived to use them. Rules in the first category are called &alpha;-rules, and rules in this category depend on only one derivation. Rules in the second category are called &beta;-rules, and rules in this category depend on two derivations. </p> <p> In each category there is exactly one rule for disjunction, one rule for implication, and one rule for conjunction. In total there are thus six rules, one for each connective, and one for the negation of each connective. There are no further rules about the negation operator, so formulas involving the negation operator must be proven either using the double negation rule or in connection with another logical connective using the &alpha;- or &beta;-rules. </p> <p> The &alpha;-rules are about formulas of the forms A &or; B, A &rarr; B, and &not; (A &and; B), while the &beta;-rules are about formulas of the forms A &and; B, &not; (A &rarr; B), and &not; (A &or; B). </p> <p> The first &alpha;-rule is called <code>Dis_R</code> and says that &vdash; A &or; B, &Gamma; is true if &vdash; A, B, &Gamma; is true. This should be obvious, since the rule just moves the connective from the object language into the metalanguage (remember that there is an implicit disjunction between the asserted formulas in a sequent calculus). Here is the rule: </p><blockquote> <code>Dis_R: &Vdash; Dis p q # z if &Vdash; p # q # z </code> </blockquote> <p></p> <p> The second &alpha;-rule is called <code>Imp_R</code> and says that &vdash; A &rarr; B, &Gamma; is true if &vdash; &not; A, B, &Gamma; is true. This rule is less intuitive, but becomes obvious when you consider the truth table definition of implication. Here is the rule: </p><blockquote> <code>Imp_R: &Vdash; Imp p q # z if &Vdash; Neg p # q # z</code> </blockquote> <p></p> <p> The third and final &alpha;-rule is called <code>Con_L</code> and says that &vdash; &not; (A &and; B), &Gamma; is true if &vdash; &not; A, &not; B, &Gamma; is true. The meaning of this rule is that at least one of the two propositions A and B must be false for the negated conjunction of the propositions to be false. Here is the rule: </p><blockquote> <code>Con_L: &Vdash; Neg (Con p q) # z if &Vdash; Neg p # Neg q # z</code> </blockquote> <p></p> <p> Notice that the conclusions of all of the &alpha;-rules depend on only a single derivation. We will now look at the &beta;-rules, whose conclusions all depend on two derivations that must both be true. </p> <p> The first &beta;-rule is called <code>Con_R</code> and says that &vdash; A &and; B, &Gamma; is true if both &vdash; A, &Gamma; and &vdash; B, &Gamma; are true. Here is the rule: </p><blockquote> <code>Con_R: &Vdash; Con p q # z if &Vdash; p # z and &Vdash; q # z </code> </blockquote> Note that, like the first &alpha;-rule, this rule just moves a connective in the object language into the metalanguage, though it does so by splitting the derivation in two parts which must both be true instead of adding both parts to the same list of formulas. It is instructive to think of the derivation as a tree that branches whenever a &beta;-rule is used. In the MiniCalc syntax, we will denote a branch in the proof using a plus (<code>+</code>). <p></p> <p> The second &beta;-rule is called <code>Imp_L</code> and says that &vdash; &not; (A &rarr; B), &Gamma; is true if both &vdash; A, &Gamma; and &vdash; &not; B, &Gamma; are true. This should again be obvious from the truth table for implication. Here is the rule: </p><blockquote> <code>Imp_L: &Vdash; Neg (Imp p q) # z if &Vdash; p # z and &Vdash; Neg q # z</code> </blockquote> <p></p> <p> The third and final &beta;-rule is called <code>Dis_L</code> and says that &vdash; &not; (A &or; B), &Gamma; is true if both &vdash; &not; A, &Gamma; and &vdash; &not; B, &Gamma; are true. Again, the connective is essentially just moved into the metalanguage. Here is the rule: </p><blockquote> <code>Dis_L: &Vdash; Neg (Dis p q) # z if &Vdash; Neg p # z and &Vdash; Neg q # z </code> </blockquote> <p></p> <p> You may have noticed that the &beta;-rules all carry any additional formulas &Gamma; (or <code>z</code> in the code syntax) into both branches of the derivation. This suggests that, like in the method of tableaux, one should always strive to use as many &alpha;-rules as possible before using any &beta;-rules to avoid duplication of work. </p> <h2>&gamma;- and &delta;-rules</h2> <p> We now know how to prove formulas involving logical connectives, but we still haven't seen how to handle quantified formulas. When we encounter a formula starting with a quantifier, we want to eliminate the quantifier so we can continue using rules on the inner formula. When we eliminate a quantifier we also need to do something about the variable bound by the quantifier. Since quantifiers generalize formulas by replacing terms with variables, we will replace the bound variable by a term when we eliminate the quantifier. The rules for eliminating quantifiers can be divided into two categories depending on which term we are allowed to replace the variable with. There are two rules in each category, one for each of the quantifiers. </p> <p> The simplest of these categories contains formulas where there are no restrictions on which term we are allowed to replace the variable with. The rules in this category are called &gamma;-rules, and concern formulas of the forms &exist; x . A(x) and &not; &forall; x . A(x). </p> <p> The first &gamma;-rule is called <code>Exi_R</code> and says that &vdash; &exist; x . A(x), &Gamma; is true if &vdash; A, &Gamma;, with the variable x replaced by some term t in A, is true. The idea is that, if we want to prove that the formula A(x) is true for some x, we need to provide a proof of the formula with x replaced by some concrete term t, which is commonly called a <em>witness</em>. If we have a proof that the formula is true for t, the formula is obviously true for some term (that term being t), so we have proven &exist; x . A(x). Here is the rule: </p><blockquote> <code>Exi_R: &Vdash; Exi p # z if &Vdash; subt t p # z</code> </blockquote> The rule uses an auxiliary function <code>subt</code>, which substitutes the term <code>t</code> into the formula <code>p</code>. It replaces the variable corresponding to the outermost quantifier, which is the one we are eliminating. <p></p> <p> The other &gamma;-rule is called <code>Uni_L</code> and says that &vdash; &not; &forall; x . A(x), &Gamma; is true if &vdash; &not; A, &Gamma;, with the variable x replaced by some term t in A, is true. The idea is that, if we want to prove that the formula A(x) is not true for every x, we need to provide a term t for which the formula does not hold. Here is the rule: </p><blockquote> <code>Uni_L: &Vdash; Neg (Uni p) # z if &Vdash; Neg (subt t p) # z</code> </blockquote> The rule is fairly similar to the other &gamma;-rule, so it should be fairly obvious how it works. <p></p> <p> The &gamma;-rules are fairly simple, but Isabelle will sometimes need help using the rules because we can replace the bound variable by <em>any</em> term. This can make Isabelle confused about which part of the new formula is our witness. In the MiniCalc syntax, we can specify which term we are replacing the bound variable with by writing an annotation e.g. <code>Exi_R[t]</code> to mean that we want to apply rule <code>Exi_R</code>, replacing the bound variable by the term <code>t</code>. This is not necessary (but it never hurts) as the annotation will automatically be added in the generated Isabelle proof anyway. </p> <p> The other category contains formulas where we must replace the variable with a <em>fresh</em> constant. A fresh constant is one which does not occur anywhere else in the list of formulas in our current proof step. The rules in this category are called &delta;-rules, and concern formulas of the forms &forall; x . A(x) and &not; &exist; x . A(x). </p> <p> The first &delta;-rule is called <code>Uni_R</code> and says that &vdash; &forall; x . A(x), &Gamma; is true if &vdash; A, &Gamma;, with the variable x replaced by a fresh constant c in A, is true. The idea is that, if we want to prove that the formula A(x) is true for every x, we can do so by proving the formula A for a fresh constant. Since the fresh constant is not mentioned anywhere else, it could be replaced by any term without changing the meaning of the formula. The formula is thus true for <em>any</em> term, which is what we wanted to prove. Here is the rule: </p><blockquote> <code>Uni_R: &Vdash; Uni p # z if &Vdash; inst c p # z and news c (p # z)</code> </blockquote> This rule uses the auxiliary function <code>inst</code> to replace the variable bound by the quantifier with a constant <code>c</code> in the formula <code>p</code>. The rule uses the auxiliary function <code>news</code> to check that a constant <code>c</code> does not occur anywhere in the list of formulas, i.e. that the constant is fresh. Note that this second part of the right hand side is a purely computational condition that can be proven by simply inspecting the list of formulas to see if <code>c</code> occurs anywhere. <p></p> <p> The second &delta;-rule is called <code>Exi_L</code> and says that &vdash; &not; &exist; x . A(x) is true if &vdash; &not; A, &Gamma;, with the variable x replaced by a fresh constant c in A, is true. The idea is that, if we want to prove that there is no x such that A(x) is true, we can do so by proving the formula &not; A for a fresh constant. Since the fresh constant is not mentioned anywhere else, it could be replaced by any term without changing the meaning of the formula. There is thus <em>no</em> term for which the formula is true, which is what we wanted to prove. Here is the rule: </p><blockquote> <code>Exi_L: &Vdash; Neg (Exi p) # z if &Vdash; Neg (inst c p) # z and news c (p # z)</code> </blockquote> The rule is very similar to the other &delta;-rule, so it should be fairly obvious how it works. <p></p> <p> We have now seen every rule in MiniCalc, so we are ready to begin proving lemmas. The rules of MiniCalc can prove any lemma in first-order logic, but unlike proofs in propositional logic, proofs in first-order logic require planning. This is mainly because of the &gamma;-rules, which require the user to <em>choose</em> a term to substitute into the formula when eliminating the quantifier. If the user chooses the wrong term, it may not be possible to continue the proof, and it is not always obvious what to choose. </p> <p> Note also that all of the &gamma;- and &delta;-rules remove the quantified formula from the list of formulas. It may sometimes be necessary to use the <code>Exi_R</code> or <code>Uni_L</code> rule multiple times on the same universally quantified formula to obtain several versions of the same formula with different terms substituted in for the variable. </p> <p> Additionally, the user might choose to eliminate quantifiers at an unfortunate step in the proof. When a &beta;-rule is used, the proof splits in two branches. If a quantifier is eliminated before this happens, the term replacing the bound variable will be the same in both branches, but if the user waits to do this until the &beta;-rule has been used, the variable can be replaced by different terms in the two branches. </p> <p> These difficulties mean that you should expect to spend a few attempts before successfully proving a formula. </p> <h1 id="examples">Some example proofs</h1> <p> This section contains a number of example proofs in the MiniCalc syntax. To try these proofs, simply copy them into MiniCalc, then copy the result into your Isabelle file. Remember to add the required header and footer to the Isabelle file as described above. </p> <p> You can copy multiple examples in at once separated by minuses (<code>-</code>) or hashes (<code>#</code>) as described above. </p> <h2>Example 1</h2> <p>The formula P(a,b) &or; &not; P(a,b) may be stated and proved as follows in MiniCalc:</p> <pre>
# "Example 1"

Dis p[a, b] (Neg p[a, b])

Dis_R
  p[a, b]
  Neg p[a, b]
Basic</pre> <h2>Example 2</h2> <p>The formula (P &and; Q(f,a(g(b)))) &rarr; P may be stated and proved as follows in MiniCalc:</p> <pre>
# "Example 2"

Imp (Con p q[f[a, g[b]]]) p

Imp_R
  Neg (Con p q[f[a, g[b]]])
  p
Con_L
  Neg p
  Neg q[f[a, g[b]]]
  p
Ext
  p
  Neg p
Basic</pre> <h2>Example 3</h2> <p>The formula (&forall;x . &forall;y . P(x,y)) &rarr; P(a,a) may be stated and proved as follows in MiniCalc:</p> <pre>
# "Example 3"

Imp (Uni (Uni p[1, 0])) p[a, a]

Imp_R
  Neg (Uni (Uni p[1, 0]))
  p[a, a]
Uni_L
  Neg (Uni p[a, 0])
  p[a, a]
Uni_L
  Neg p[a, a]
  p[a, a]
Ext
  p[a, a]
  Neg p[a, a]
Basic</pre> <h2>Example 4</h2> <p>The formula (&forall;x . P(x) &rarr; Q(x)) &rarr; ((&exist;x . P(x)) &rarr; (&exist;x . Q(x))) may be stated and proved as follows in MiniCalc: </p> <pre>
# "Example 4"

Imp (Uni (Imp p[0] q[0])) (Imp (Exi p[0]) (Exi q[0]))

Imp_R
  Neg (Uni (Imp p[0] q[0]))
  Imp (Exi p[0]) (Exi q[0])
Ext
  Imp (Exi p[0]) (Exi q[0])
  Neg (Uni (Imp p[0] q[0]))
Imp_R
  Neg (Exi p[0])
  Exi q[0]
  Neg (Uni (Imp p[0] q[0]))
Exi_L
  Neg p[a]
  Exi q[0]
  Neg (Uni (Imp p[0] q[0]))
Ext
  Neg (Uni (Imp p[0] q[0]))
  Neg p[a]
  Exi q[0]
Uni_L
  Neg (Imp p[a] q[a])
  Neg p[a]
  Exi q[0]
Imp_L
  p[a]
  Neg p[a]
  Exi q[0]
+
  Neg q[a]
  Neg p[a]
  Exi q[0]
Basic
  Neg q[a]
  Neg p[a]
  Exi q[0]
Ext
  Exi q[0]
  Neg q[a]
Exi_R
  q[a]
  Neg q[a]
Basic</pre> </section> <script type="module">function n(n){navigator.clipboard?navigator.clipboard.writeText(n):function(n){var p=document.createElement("textarea");p.value=n,p.style.top="0",p.style.left="0",p.style.position="fixed",document.body.appendChild(p),p.focus(),p.select();try{document.execCommand("copy")}catch(n){console.error("Unable to copy",n)}document.body.removeChild(p)}(n)}var p="Empty result ";function e(){return p}var a=document.querySelector("#clipboard-btn");a&&a.addEventListener("click",(function(p){"Empty result "!==e()&&n(e().replace(/ /g," ").slice(0,-1))}));var i=document.querySelector("#example-btn");i&&i.addEventListener("click",(function(p){n('# "Example 1"\n\n(* Proof of formula p a b ∨ ¬ p a *)\n\nDis p[a, b] (Neg p[a, b])\n\nDis_R\n  p[a, b]\n  Neg p[a, b]\nBasic\n\n# "Example 2"\n\n(* Proof of formula (p ∧ q (f a (g b))) ⟶ p *)\n\nImp (Con p q[f[a, g[b]]]) p\n\nImp_R\n  Neg (Con p q[f[a, g[b]]])\n  p\nCon_L\n  Neg p\n  Neg q[f[a, g[b]]]\n  p\nExt\n  p\n  Neg p\nBasic\n \n# "Example 3"\n\n(* Proof of formula (∀x y. p x y) ⟶ p a a *)\n\nImp (Uni (Uni p[1, 0])) p[a, a]\n\nImp_R\n  Neg (Uni (Uni p[1, 0]))\n  p[a, a]\nUni_L\n  Neg (Uni p[a, 0])\n  p[a, a]\nUni_L\n  Neg p[a, a]\n  p[a, a]\nExt\n  p[a, a]\n  Neg p[a, a]\nBasic\n\n# "Example 4"\n\n(* Proof of formula (∀x. p x ⟶ q x) ⟶ (∃x. p x) ⟶ (∃x. q x) *)\n\nImp (Uni (Imp p[0] q[0])) (Imp (Exi p[0]) (Exi q[0]))\n\nImp_R\n  Neg (Uni (Imp p[0] q[0]))\n  Imp (Exi p[0]) (Exi q[0])\nExt\n  Imp (Exi p[0]) (Exi q[0])\n  Neg (Uni (Imp p[0] q[0]))\nImp_R\n  Neg (Exi p[0])\n  Exi q[0]\n  Neg (Uni (Imp p[0] q[0]))\nExi_L\n  Neg p[a]\n  Exi q[0]\n  Neg (Uni (Imp p[0] q[0]))\nExt\n  Neg (Uni (Imp p[0] q[0]))\n  Neg p[a]\n  Exi q[0]\nUni_L\n  Neg (Imp p[a] q[a])\n  Neg p[a]\n  Exi q[0]\nImp_L\n  p[a]\n  Neg p[a]\n  Exi q[0]\n+\n  Neg q[a]\n  Neg p[a]\n  Exi q[0]\nBasic\n  Neg q[a]\n  Neg p[a]\n  Exi q[0]\nExt\n  Exi q[0]\n  Neg q[a]\nExi_R\n  q[a]\n  Neg q[a]\nBasic\n')}));</script> </body></html>