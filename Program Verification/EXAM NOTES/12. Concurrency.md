# Module 12: Concurrency - Quick Revision Summary

> [!SUMMARY] Key Topics
> 1. **Concurrency Challenges**
>    - Data races (2+ threads, 1 mutates)
>    - Deadlocks (cyclic lock dependencies)
>    - Thread interference (functional correctness)
>    - Thread cooperation (Owicki-Gries counter example)
>
> 2. **Thread-modular Verification**
>    - Procedure-modular + thread-modular approach
>    - Permission transfer mechanisms
>    - Proof rule: `{{ F1 * F2 }} C1 || C2 {{ H1 * H2 }}`
>
> 3. **Synchronization Mechanisms**
>    - Lock invariants
>    - Coarse-grained vs. fine-grained locking
>    - Hand-over-hand locking pattern
>
> 4. **Implementation Patterns**
>    - Client-side vs. server-side locking
>    - Thread field management
>    - Fork/Join operations
>    - Permission handling

> [!TIP] Exam Focus
> - Understand permission transfer and separation logic
> - Know lock invariant patterns and their verification
> - Be able to explain both simple and complex locking strategies
> - Recognize and prevent concurrency issues (races, deadlocks)
> - Be prepared to work with code examples involving parallel composition

> [!NOTE] Key Formulas/Rules
> ```viper
> // Lock invariant example
> define Inv(this) (
>     acc(this.val) &&
>     acc(this.c1, 1/2) && acc(this.c2, 1/2) &&
>     this.val == this.c1 + this.c2
> )
> 
> // Soundness
> ⊢ {{ F }} C {{ H }} implies ⊨ {{ F }} C {{ H }}
> ```

# Concurrency (Module 12)

## Key Concepts

### Thread-Local State vs. Shared State
> [!important] 
> Two main scenarios for concurrent programs:
> 1. Concurrency with thread-local state
> 2. Shared state and synchronization

### Challenges in Concurrent Programs
1. **Data Races**
   - Occurs when 2+ threads access same data with at least one mutating data
   - Data may be corrupted, non-deterministic behavior
   - Need to verify absence of data races

2. **Deadlocks**
   - Example:
```python
acquire x           acquire y
acquire y           acquire x
...                ...
release x          release x
release y          release y
```

3. **Thread Interference**
   - Proving functional correctness becomes harder with concurrency
   - Other threads might interfere with execution
   - Must account for all possible thread interactions

4. **Thread Cooperation**
   - Sometimes threads need to cooperate to achieve a goal
   - Example: Owicki-Gries counter
   - Requires careful synchronization

## Thread-modular Verification

### Key Principles
1. All verification techniques are procedure-modular
   - Reason about calls using callee's specification
   - Verification independent of caller/callee implementation

2. Thread-modular approach
   - Reason about thread execution without knowing concurrent threads
   - Essential for scalability

### Permission Transfer
For structured parallelism:
```
{{ F1 }} C1 {{ H1 }} {{ F2 }} C2 {{ H2 }}
{{ F1 * F2 }} C1 || C2 {{ H1 * H2 }}
```
> [!note] 
> The `*` operator represents separating conjunction, ensuring disjoint resources

## Lock-based Synchronization

### Lock Invariants
```viper
// Example lock invariant
define Inv(this) (
    acc(this.cache) &&
    (this.cache != null ==> acc(this.cache.val, wildcard))
)
```

### Types of Locking
1. **Coarse-grained Locking**
   - Uses single lock for entire data structure
   - Simple but limits concurrency

2. **Fine-grained Locking**
   - Multiple locks for different parts
   - Better concurrency but more complex
   - Example: Hand-over-hand locking for lists

> [!example] Hand-over-hand Locking Rules
> - Hold at most two locks at a time
> - Acquire successor's lock before releasing predecessor's
> - Required for maintaining complex invariants

## Verification Rules & Theorems

1. **Soundness**
```latex
⊢ {{ F }} C {{ H }} implies ⊨ {{ F }} C {{ H }}
```

2. **Lock Invariant Rule**
- Must hold whenever lock is not held by any thread
- Must be self-framing for soundness

## Exam Tips
> [!tip] 
> - Focus on understanding permission transfer mechanisms
> - Be able to explain both coarse and fine-grained locking approaches
> - Know how to prevent data races using permissions
> - Understand the difference between client-side and server-side locking
> - Be prepared to discuss lock invariants and their importance

# Concurrency (Module 12) - Part 2

## Advanced Concurrency Patterns

### Fork and Join Operations
1. **Fork Operation**
```viper
t := new(pArg)
t.pArg := 5
exhale P[p ↦ 5]
```

2. **Join Operation**
```viper
inhale Q[p ↦ t.pArg, r ↦ y]
```

> [!important] Join Challenges
> - Must identify postcondition to inhale
> - Need to handle method parameters correctly
> - Corresponding fork not always statically known

### Thread Field Management
```viper
field thisArg: Ref
field joinable: Bool
```

## Parallel List Search Example

### Base Implementation
```viper
method busy(courses: Ref, seminars: Ref, today: Int) returns (res: Bool)
    requires list(courses) && list(seminars)
    ensures list(courses) && list(seminars)
    ensures res == (today in content(courses) || today in content(seminars))
{
    var r1: Bool; var r2: Bool
    var t1: Thread<contains>; var t2: Thread<contains>
    t1 := fork contains(courses, today)
    t2 := fork contains(seminars, today)
    r1 := join t1
    r2 := join t2
    res := r1 || r2
}
```

## Server-Side vs Client-Side Locking

### Client-Side Example
```viper
method inc(cell: Ref)
    requires acc(cell.val)
    ensures acc(cell.val)
    ensures cell.val == old(cell.val) + 1
{
    cell.val := cell.val + 1
}
```

### Server-Side Example
```viper
method inc(cell: Ref)
    requires acc(cell.isLock, wildcard)
{
    acquire cell
    cell.val := cell.val + 1
    release cell
}
```

> [!warning] Server-Side Limitations
> - Cannot provide strong postconditions
> - Permission not held in post-state
> - May require ghost state for reasoning

## Complex Invariants with Fine-Grained Locking

### Example: Sorted List Invariant
```viper
define InvNode(this) (
    acc(this.elem, 1/2) && acc(this.next) &&
    (this.next != null ==> 
        acc(this.next.elem, 1/2) &&
        acc(this.next.isLock, wildcard) &&
        this.elem <= this.next.elem)
)
```

### Implementation Considerations
1. **Lock Acquisition Order**
   - Must prevent deadlocks
   - Follow consistent ordering

2. **Permission Management**
   - Track fractional permissions
   - Ensure proper transfer between threads

3. **Invariant Maintenance**
   - Handle boundary conditions
   - Maintain properties during transitions

## Deadlock Prevention Techniques

### Basic Rules
1. Acquire locks in fixed order
2. Use timeouts
3. Detect and recover
4. Use lock hierarchies

### Example Pattern
```viper
// Safe pattern
acquireList(this)
var curr: Ref := this.head
if(curr != null) {
    acquireNode(curr)
    // ... operations ...
    releaseList(this)
}
```

## Research Areas & Advanced Topics

1. **Properties**
   - Deadlock freedom
   - Starvation freedom
   - Fairness
   - Linearizability

2. **Synchronization Primitives**
   - Message passing
   - Barriers
   - Condition variables

3. **Implementation Techniques**
   - Lock-free algorithms
   - Weak memory models
   - Wait-free synchronization

> [!tip] Exam Focus Areas
> - Understanding of both structured and unstructured parallelism
> - Ability to explain different locking strategies
> - Knowledge of permission transfer mechanics
> - Familiarity with common concurrent patterns
> - Awareness of verification challenges

# Exam Preparation Tips & Real Examples from Lecture

## Example 1: Permission Handling in Concurrent Programs

### Thread-local State Example
```viper
method produce(buf: Ref)
{
    while(true) {
        acquire buf
        if(buf.val == null) {
            buf.val := new()
        }
        release buf
    }
}
```

> [!important] Verification Focus
> - Check how permissions are transferred between threads
> - Understand lock invariants
> - Look for potential data races

## Example 2: Hand-over-Hand Locking (From Lecture)

### Implementation Pattern
```viper
method incAll(this: Ref)
    requires acc(this.isLock, wildcard)
{
    acquireList(this)
    var curr: Ref := this.head
    if(curr != null) {
        acquireNode(curr)
        curr.elem := curr.elem + 1
        releaseList(this)
        var n: Ref := curr.next
        // ... continued locking pattern
    }
}
```

> [!note] Key Verification Aspects
> 1. Maximum two locks held at any time
> 2. Lock successor before releasing predecessor
> 3. Maintain invariants throughout

## Example 3: Owicki-Gries Counter (From Lecture Demo)

```viper
field val: Int
field c1: Int  // Ghost fields
field c2: Int  

define Inv(this) (
    acc(this.val) &&
    acc(this.c1, 1/2) && acc(this.c2, 1/2) &&
    this.val == this.c1 + this.c2
)
```

> [!tip] Exam Strategies
> 1. Be prepared to explain ghost state usage
> 2. Understand how invariants are maintained
> 3. Recognize parallel composition patterns

## Common Exam Questions & Tips

### Type 1: Soundness Questions
> [!example] Example Question
> "What does it mean for a verification technique to be sound?"
> ```
> Formally: ⊢ {{ F }} C {{ H }} implies ⊨ {{ F }} C {{ H }}
> ```

### Type 2: Code Analysis
```viper
inhale acc(x.f) && acc(y.f)
if (x != y) {
    exhale acc(x.f, ½)
    y.f := x.f
} else {
    assert false
}
```
> [!tip] Analysis Strategy
> 1. Check permission handling
> 2. Look for potential data races
> 3. Verify invariant maintenance

### Type 3: Complex Pattern Implementation
Example from lecture: Implementing fine-grained locking for a sorted list

```viper
define InvNode(this) (
    acc(this.elem) && acc(this.next) &&
    (this.next != null ==> 
        acc(this.next.isLock, wildcard) &&
        this.elem <= this.next.elem)
)
```

## Verification Framework Understanding

1. Know the verification stack:
   - Source code with specifications
   - Concurrency layer
   - Heaps & objects
   - Loop and procedure handling
   - SMT solving

2. Be prepared to explain:
   - How permissions prevent data races
   - Why lock invariants must be self-framing
   - Differences between locking strategies

> [!warning] Common Pitfalls
> - Not considering all thread interactions
> - Forgetting to maintain invariants
> - Missing permission checks
> - Incorrect lock ordering leading to deadlocks

