
| Metavariable             | Meaning                                 |
| ------------------------ | --------------------------------------- |
| $n, m$                   | natural numbers taken from $\mathbb{N}$ |
| $\Sigma$                 | signature                               |
| $f$                      | function symbol                         |
| $R$                      | relation symbol                         |
| $c$                      | constant symbol                         |
| $\mathfrak{A}$           | structure                               |
| $A$                      | universe of $\mathfrak{A}$              |
| $\mathfrak{R}$           | the structure of standard arithmetic    |
| $x, y, z$                | variables                               |
| $t$                      | term                                    |
| $F, G, H$                | formulae                                |
| $\upsilon$               | variable assignment                     |
| $\mathfrak{I}$           | interpretation                          |
| $\mathbf{AX}$            | axiom system                            |
| $\mathbf{T}, \mathbf{S}$ | sorts                                   |

## Key Concepts

### Foundational Elements
- Program verification can be reduced to solving an *entailment problem*: 
  $\ff \Entails \fg$
- Entailment means all $\mem$ that satisfy $\ff$ also satisfy $\fg$

### First-Order Predicate Logic (FOL)
- Base framework that generalizes simpler formulae
- Needed because propositional logic alone is insufficient for program verification
- Must support:
  - Integer-valued variables
  - Numeric constants
  - Arithmetic operations
  - Comparisons
  - Multiple types (lists, trees, maps, arrays)
  - Quantifiers

### Structures & Signatures

> [!info] Signature Definition
> A *signature* is a pair $\Sigma = \tuple{\mathbf{Fun}, \mathbf{Rel}}$, where:
> - $\mathbf{Fun}$ is a set of function symbols
> - $\mathbf{Rel}$ is a set of relation symbols
> - Each symbol has an *arity* (number of parameters)

### Terms & Formulae
- Terms are expressions composed from:
  - Variables
  - Constant symbols 
  - Function symbols
- Formulae combine:
  - Relations between terms
  - Logical connectives
  - Quantifiers

## Important Concepts for Verification

### SMT (Satisfiability Modulo Theories)
1. What is SMT?
   - Checks if formula is satisfiable under specific theories
   - Can encode verification problems into SMT
   - Different theories have different decidability properties

2. Common Theories:
   - EQ (Theory of Equality)
   - EUF (Equality with Uninterpreted Functions)
   - Arithmetic Theories (Real, Integer, Linear)
   - Arrays

> [!tip] Exam Tip
> Understanding which theories are decidable and which are not is important:
> - Real arithmetic: Decidable
> - Peano arithmetic: Undecidable
> - Presburger arithmetic (no multiplication): Decidable

### Working with Quantifiers
- Universal quantifiers ($\forall$) common in axioms
- E-matching used to control quantifier instantiation
- Patterns help guide the SMT solver
- Poor pattern choice can lead to non-termination

## Practical Considerations

### SMT Solver Usage
1. Input format: SMT-LIB
   ```lisp
   (declare-const x Int)
   (assert (> x 0))
   (check-sat)
   ```
2. Common Results:
	- sat (satisfiable)
    - unsat (unsatisfiable)
    - unknown (cannot determine)

>[!warning] Common Pitfalls
>
> - Non-termination with quantifiers
> - Memory exhaustion in matching loops
> - Using wrong theories for the problem

## Exam Tips

- Focus on understanding:
    1. When to use which theory
    2. Decidability implications
    3. Pattern selection for quantifiers
    4. Translation of verification problems to SMT
- Be prepared to explain soundness and completeness
- Practice writing and analyzing simple SMT-LIB code


$$
% ---------- Memory ----------
\newcommand{\memory}{\mathfrak{m}}
\newcommand{\mem}{\memory}

% ---------- Floyd-Hoare Logic ----------
\newcommand{\triple}[3]{{\color{blue!80}\{\!\{~#1~\}\!\}}~#2~{\color{blue!80}\{\!\{~#3~\}\!\}}}
\newcommand{\Triple}[3]{\triple{#1}{#2}{#3}}

% ---------- Conditional and Control Structures ----------
\newcommand{\choice}[2]{\{~#1~\}~\texttt{[]}~\{~#2~\}}
\newcommand{\ite}[3]{\texttt{if}~(#1)~\{~#2~\}~\texttt{else}~\{~#3~\}}
\newcommand{\Ite}[3]{\texttt{if}~(#1)~\{~#2~\}~\texttt{else}~\{~#3~\}}
\newcommand{\WhileDo}[2]{\texttt{while}~(#1)~\{#2\}}
\newcommand{\IfThenElse}[3]{\texttt{if}~(#1)~\{#2\}~\texttt{else}~\{#3\}}
\newcommand{\Done}{\texttt{done}}
\newcommand{\Abort}{\texttt{abort}}
\newcommand{\Skip}{\texttt{skip}}
\newcommand{\Seq}{;}
\newcommand{\Begin}{\{}
\newcommand{\End}{\}}
\newcommand{\Choice}{\texttt{[]}}

% ---------- Assertions and Assumptions ----------
\newcommand{\Assert}[1]{\texttt{assert}~#1}
\newcommand{\Assume}[1]{\texttt{assume}~#1}
\newcommand{\AssertI}[1]{\texttt{assert}~#1}
\newcommand{\AssumeI}[1]{\texttt{assume}~#1}

% ---------- Matching and Cases ----------
\newcommand{\Match}[1]{\texttt{match}~\{~#1~\}}
\newcommand{\Case}[2]{#1~\texttt{=>}~#2}
\newcommand{\default}{\texttt{default}}

% ---------- Assignment and Updates ----------
\newcommand{\Assign}[2]{#1 := #2}
\newcommand{\Havoc}[1]{\texttt{havoc}~#1}
\newcommand{\VarAssign}[3]{\texttt{var}~#1:~#2~:=~#3}
\newcommand{\Var}[2]{\texttt{var}~#1:~#2}

% ---------- Expressions ----------
\newcommand{\UniverseOf}[1]{\mathbf{A}(#1)}
\newcommand{\VarsOf}[1]{\mathbf{Var}(#1)}
\newcommand{\tof}[2]{#1 : #2}
\newcommand{\eval}[2]{#1 \leftarrow [#2](\memory)}
\newcommand{\iUpdate}[2]{[#1\leftarrow#2]}
\newcommand{\evalE}[1]{[#1]}

% ---------- Substitution ----------
\newcommand{\subst}[2]{[#1 := #2]}
\newcommand{\Subst}[2]{[#1 := #2]}

% ---------- Logic and Quantifiers ----------
\newcommand{\Exists}{\exists}
\newcommand{\Forall}{\forall}
\newcommand{\qiff}{\text{ iff }}
\newcommand{\texists}{\text{ there exists }}
\newcommand{\tsuch}{\text{ such that }}
\newcommand{\qdot}{\,.\,}
\newcommand{\Implies}{\rightarrow}
\newcommand{\Neg}[1]{\neg #1}
% ---------- Boolean and Comparison Operators ----------
\newcommand{\True}{\texttt{true}}
\newcommand{\False}{\texttt{false}}
\newcommand{\teq}{~\texttt{==}~}
\newcommand{\eq}{=}
\newcommand{\defqeq}{\stackrel{\text{def}}{=}}
\newcommand{\defeq}{\defqeq}

% ---------- Configurations and Judgements ----------
\newcommand{\conf}[1]{\langle\, #1 \,\rangle}
\newcommand{\tuple}[1]{\langle\, #1 \,\rangle}
\newcommand{\qopStep}{\step}
\newcommand{\step}{~\Rightarrow~}
\newcommand{\valid}{\models}
\newcommand{\Entails}{\models}
\newcommand{\provable}{\vdash}
\newcommand{\JudgeSyn}{\vdash}
\newcommand{\Satisfies}{\models}
\newcommand{\tsep}{,~}
\newcommand{\Configurations}{\texttt{Conf}}
\newcommand{\Variant}{\textit{V}}

% ---------- Typing ----------
\newcommand{\TT}{\texttt{T}}

% ---------- Programs and Commands ----------
\newcommand{\Block}{\texttt{begin}~\textit{C}~\texttt{end}}
\newcommand{\Vc}[2]{\text{VC}\left(#1, #2\right)}
\newcommand{\BlockBegin}{\texttt{begin}}
\newcommand{\BlockEnd}{\texttt{end}}
\newcommand{\Wp}[2]{\mathbf{wp}[#1](#2)}
\renewcommand{\wp}{\Wp}
\newcommand{\swp}[2]{\mathbf{swp}[#1](#2)}
\newcommand{\Invariant}{\textit{Inv}}
\newcommand{\Inv}{\textit{Inv}}
\newcommand{\return}{\texttt{return}}
\newcommand{\nop}{\texttt{nop}}

% ---------- Auxiliary Variables and Symbols ----------
\newcommand{\cc}{C}
\newcommand{\ff}{\mathit{F}}
\newcommand{\X}{\textbf{X}}
\newcommand{\bb}{b}
\newcommand{\x}{\texttt{x}}
\newcommand{\y}{\texttt{y}}
\newcommand{\ee}{\texttt{e}}
\newcommand{\F}{\textit{F}}
\newcommand{\A}{\mathfrak{A}}
\newcommand{\vv}{\mathit{v}}
\newcommand{\vu}{\mathit{u}}
\newcommand{\SetComp}[2]{\left\{ #1 \mid #2 \right\}}
\newcommand{\AX}{\textbf{AX}}
\newcommand{\fg}{G}
\newcommand{\WhileDoInv}[2]{\texttt{while}~(#1)~\texttt{invariant}~#2}
% ---------- Meta-Variables ----------
\newcommand{\Pre}{P}
\newcommand{\Post}{Q}
\newcommand{\confTerm}{\Done}

% ---------- Magic and Additional Commands ----------
\newcommand{\Magic}{\texttt{magic}}
\newcommand{\Declared}[1]{\textbf{Declared}(#1)}
\newcommand{\Mems}{\texttt{Mem}}
\newcommand{\Scopes}{\mathcal{S}}
\newcommand{\RestoreScope}{\texttt{RestoreScope}}
\newcommand{\enc}[1]{[#1]}
\newcommand{\Encode}[1]{\texttt{enc}(#1)}
\newcommand{\opStep}{\step}
\newcommand{\VarSet}{\texttt{Var}}
\newcommand{\Universe}{\mathfrak{A}}
\newcommand{\Set}[1]{\{#1\}}
\newcommand{\ModVarsOf}[1]{\mathbf{Mod}(#1)}
\newcommand{\xs}{\texttt{x}}
\newcommand{\ForDo}[4]{\texttt{for}~#1~\texttt{in}~#2..#3~\{#4\}}
\newcommand{\defq}{\stackrel{\text{def}}{=}}
$$