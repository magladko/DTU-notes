
| Metavariable             | Meaning                                 |
| ------------------------ | --------------------------------------- |
| $n, m$                   | natural numbers taken from $\mathbb{N}$ |
| $\Sigma$                 | signature                               |
| $f$                      | function symbol                         |
| $R$                      | relation symbol                         |
| $c$                      | constant symbol                         |
| $\mathfrak{A}$           | structure                               |
| $A$                      | universe of $\mathfrak{A}$              |
| $\mathfrak{R}$           | the structure of standard arithmetic    |
| $x, y, z$                | variables                               |
| $t$                      | term                                    |
| $F, G, H$                | formulae                                |
| $\mathfrak{v}$           | variable assignment                     |
| $\mathfrak{I}$           | interpretation                          |
| $\mathbf{AX}$            | axiom system                            |
| $\mathbf{T}, \mathbf{S}$ | sorts                                   |

## Key Concepts

### Foundational Elements
- Program verification can be reduced to solving an *entailment problem*: 
  $\ff \Entails \fg$
- Entailment means all $\mem$ that satisfy $\ff$ also satisfy $\fg$

### First-Order Predicate Logic (FOL)
- Base framework that generalizes simpler formulae
- Needed because propositional logic alone is insufficient for program verification
- Must support:
  - Integer-valued variables
  - Numeric constants
  - Arithmetic operations
  - Comparisons
  - Multiple types (lists, trees, maps, arrays)
  - Quantifiers

### Structures & Signatures

> [!info] Signature Definition
> A *signature* is a pair $\Sigma = \tuple{\mathbf{Fun}, \mathbf{Rel}}$, where:
> - $\mathbf{Fun}$ is a set of function symbols
> - $\mathbf{Rel}$ is a set of relation symbols
> - Each symbol has an *arity* (number of parameters)

### Terms & Formulae
- Terms are expressions composed from:
  - Variables
  - Constant symbols 
  - Function symbols
- Formulae combine:
  - Relations between terms
  - Logical connectives
  - Quantifiers

## Important Concepts for Verification

### SMT (Satisfiability Modulo Theories)
1. What is SMT?
   - Checks if formula is satisfiable under specific theories
   - Can encode verification problems into SMT
   - Different theories have different decidability properties

2. Common Theories:
   - EQ (Theory of Equality)
   - EUF (Equality with Uninterpreted Functions)
   - Arithmetic Theories (Real, Integer, Linear)
   - Arrays

> [!tip] Exam Tip
> Understanding which theories are decidable and which are not is important:
> - Real arithmetic: **Decidable**
> - Peano arithmetic: **Undecidable**
> - Presburger arithmetic (no multiplication): **Decidable**

### Working with Quantifiers
- Universal quantifiers ($\forall$) common in axioms
- E-matching used to control quantifier instantiation
- Patterns help guide the SMT solver
- Poor pattern choice can lead to non-termination

## Practical Considerations

### SMT Solver Usage
1. Input format: SMT-LIB
   ```lisp
   (declare-const x Int)
   (assert (> x 0))
   (check-sat)
   ```
2. Common Results:
	- sat (satisfiable)
    - unsat (unsatisfiable)
    - unknown (cannot determine)

>[!warning] Common Pitfalls
>
> - Non-termination with quantifiers
> - Memory exhaustion in matching loops
> - Using wrong theories for the problem

## Exam Tips

- Focus on understanding:
    1. When to use which theory
    2. Decidability implications
    3. Pattern selection for quantifiers
    4. Translation of verification problems to SMT
- Be prepared to explain soundness and completeness
- Practice writing and analyzing simple SMT-LIB code

# Important Definitions Reference

## Foundational Definitions

### Variables
$\Vars \defqeq \Set{\x,\y,\z, \ldots}$ is an arbitrary, but fixed, finite set of *variable names*.

### Signatures
A *signature* is a pair $\Signature = \tuple{\Functions, \Relations}$, where:
- $\Functions$ is a set of *function symbols* 
- $\Relations$ is a set of *relation symbols*
- $\Functions \cap \Relations \eq \emptyset$
- Every symbol has an *arity* $n \geq 0$
- Function symbols of arity 0 are called *constant symbols*
- Relations must have arity $n \geq 1$

### Structures
A $\Signature$-*structure* $\Structure \eq \tuple{\Universe, \Interpreted{\fun}, \Interpreted{\rel}, \ldots}$ consists of:
- A non-empty set $\Universe$ called the *universe* (or carrier)
- An $n$-ary function $\Interpreted{\fun}\colon \Universe^n \to \Universe$ for every function symbol
- An $n$-ary relation $\Interpreted{\rel} \subseteq \Universe^n$ for every relation symbol

### Terms 
The set of $\Signature$-*terms* $\Term$ is given by the grammar:
$$
\begin{aligned}
\Term \qq{\EBNF} & \x & \text{(variable)} \\
\qq{|} & \const & \text{(constant)} \\
\qq{|} & \fun(\Term_1, \ldots, \Term_n), & \text{(function application)}
\end{aligned}
$$
A term is *ground* if it contains no variables.

### Formulae
$\Signature$-*formulae* are composed of:
- Relations between $\Signature$-terms
- Logical connectives ($\Neg, \And, \Or, \Implies, \Equivalent$)
- Quantifiers ($\Exists, \Forall$)

### Interpretations
A *$\Signature$-interpretation* $\Interpretation \eq \tuple{\Structure,\VarAssignment}$ consists of:
- A $\Signature$-structure $\Structure$ with universe $\Universe$
- A function $\VarAssignment\colon \Vars \to \Universe$ assigning values to variables

## SMT-Related Definitions

### Patterns
A *pattern* for $\Forall \xs\qdot \ff$ is a term $p$ where:
- $p$ contains all quantified variables in $\xs$
- $p$ contains at least one non-constant *uninterpreted* function
- $p$ contains at most constant *interpreted* functions

### E-Matching
A sequence of terms $\ees$ *E-matches* a pattern $p$ over variables $\xs$ with respect to formula $\fg$ if:
- There exists a term $\Term$ in $\fg$ such that:
  $\fg \qq{\Entails} \Term \teq p\subst{\xs}{\ees}$

### Satisfiability Modulo Theories
A $\Signature$-formula $\ff$ is *satisfiable modulo the theory of* $\AX$ if:
- There exists a $\Signature$-interpretation $\Interpretation$ where:
  $\Interpretation \Satisfies \AX \qand \Interpretation \Satisfies \ff$

### Validity Modulo Theories
A $\Signature$-formula $\ff$ is *valid modulo the theory of* $\AX$ if:
- For every $\Signature$-interpretation $\Interpretation$:
  $\Interpretation \Satisfies \AX \qimplies \Interpretation \Satisfies \ff$

### Entailment Modulo Theories
A formula $\ff$ *entails* formula $\fg$ modulo theory $\AX$ if:
- For every interpretation $\Interpretation$ with $\Interpretation \Satisfies \AX$:
  $\Interpretation \Satisfies \ff \qimplies \Interpretation \Satisfies \fg$


$$
\newcommand{\Vars}{\mathbf{Var}}
\newcommand{\Signature}{\Sigma}
\newcommand{\Functions}{\mathbf{Fun}}
\newcommand{\Relations}{\mathbf{Rel}}
\newcommand{\Structure}{\mathfrak{A}}
\newcommand{\Interpretation}{\mathfrak{I}}
\newcommand{\ees}{\bar{e}}
\newcommand{\Term}{t}
\newcommand{\qimplies}{\quad\text{implies}\quad}
\newcommand{\qq}[1]{\quad#1\quad}
\newcommand{\qand}{\quad\text{and}\quad}
\newcommand{\VarAssignment}{\mathfrak{v}}
\newcommand{\Or}{\lor}
\newcommand{\Equivalent}{\leftrightarrow}
\newcommand{\EBNF}{\mathfrak{::=}}
\newcommand{\const}{c}
\newcommand{\fun}{f}
\newcommand{\Interpreted}[1]{#1^\Structure}
\newcommand{\rel}{R}

% ---------- Memory ----------
\newcommand{\memory}{\mathfrak{m}}
\newcommand{\mem}{\memory}

% ---------- Floyd-Hoare Logic ----------
\newcommand{\triple}[3]{{\color{blue!80}\{\!\{~#1~\}\!\}}~#2~{\color{blue!80}\{\!\{~#3~\}\!\}}}
\newcommand{\Triple}[3]{\triple{#1}{#2}{#3}}

% ---------- Conditional and Control Structures ----------
\newcommand{\choice}[2]{\{~#1~\}~\texttt{[]}~\{~#2~\}}
\newcommand{\ite}[3]{\texttt{if}~(#1)~\{~#2~\}~\texttt{else}~\{~#3~\}}
\newcommand{\Ite}[3]{\texttt{if}~(#1)~\{~#2~\}~\texttt{else}~\{~#3~\}}
\newcommand{\WhileDo}[2]{\texttt{while}~(#1)~\{#2\}}
\newcommand{\IfThenElse}[3]{\texttt{if}~(#1)~\{#2\}~\texttt{else}~\{#3\}}
\newcommand{\Done}{\texttt{done}}
\newcommand{\Abort}{\texttt{abort}}
\newcommand{\Skip}{\texttt{skip}}
\newcommand{\Seq}{;}
\newcommand{\Begin}{\{}
\newcommand{\End}{\}}
\newcommand{\Choice}{\texttt{[]}}

% ---------- Assertions and Assumptions ----------
\newcommand{\Assert}[1]{\texttt{assert}~#1}
\newcommand{\Assume}[1]{\texttt{assume}~#1}
\newcommand{\AssertI}[1]{\texttt{assert}~#1}
\newcommand{\AssumeI}[1]{\texttt{assume}~#1}

% ---------- Matching and Cases ----------
\newcommand{\Match}[1]{\texttt{match}~\{~#1~\}}
\newcommand{\Case}[2]{#1~\texttt{=>}~#2}
\newcommand{\default}{\texttt{default}}

% ---------- Assignment and Updates ----------
\newcommand{\Assign}[2]{#1 := #2}
\newcommand{\Havoc}[1]{\texttt{havoc}~#1}
\newcommand{\VarAssign}[3]{\texttt{var}~#1:~#2~:=~#3}
\newcommand{\Var}[2]{\texttt{var}~#1:~#2}

% ---------- Expressions ----------
\newcommand{\UniverseOf}[1]{\mathbf{A}(#1)}
\newcommand{\VarsOf}[1]{\mathbf{Var}(#1)}
\newcommand{\tof}[2]{#1 : #2}
\newcommand{\eval}[2]{#1 \leftarrow [#2](\memory)}
\newcommand{\iUpdate}[2]{[#1\leftarrow#2]}
\newcommand{\evalE}[1]{[#1]}

% ---------- Substitution ----------
\newcommand{\subst}[2]{[#1 := #2]}
\newcommand{\Subst}[2]{[#1 := #2]}

% ---------- Logic and Quantifiers ----------
\newcommand{\Exists}{\exists}
\newcommand{\Forall}{\forall}
\newcommand{\qiff}{\text{ iff }}
\newcommand{\texists}{\text{ there exists }}
\newcommand{\tsuch}{\text{ such that }}
\newcommand{\qdot}{\,.\,}
\newcommand{\Implies}{\rightarrow}
\newcommand{\Neg}[1]{\neg #1}
% ---------- Boolean and Comparison Operators ----------
\newcommand{\True}{\texttt{true}}
\newcommand{\False}{\texttt{false}}
\newcommand{\teq}{~\texttt{==}~}
\newcommand{\eq}{=}
\newcommand{\defqeq}{\stackrel{\text{def}}{=}}
\newcommand{\defeq}{\defqeq}

% ---------- Configurations and Judgements ----------
\newcommand{\conf}[1]{\langle\, #1 \,\rangle}
\newcommand{\tuple}[1]{\langle\, #1 \,\rangle}
\newcommand{\qopStep}{\step}
\newcommand{\step}{~\Rightarrow~}
\newcommand{\valid}{\models}
\newcommand{\Entails}{\models}
\newcommand{\provable}{\vdash}
\newcommand{\JudgeSyn}{\vdash}
\newcommand{\Satisfies}{\models}
\newcommand{\tsep}{,~}
\newcommand{\Configurations}{\texttt{Conf}}
\newcommand{\Variant}{\textit{V}}

% ---------- Typing ----------
\newcommand{\TT}{\texttt{T}}

% ---------- Programs and Commands ----------
\newcommand{\Block}{\texttt{begin}~\textit{C}~\texttt{end}}
\newcommand{\Vc}[2]{\text{VC}\left(#1, #2\right)}
\newcommand{\BlockBegin}{\texttt{begin}}
\newcommand{\BlockEnd}{\texttt{end}}
\newcommand{\Wp}[2]{\mathbf{wp}[#1](#2)}
\renewcommand{\wp}{\Wp}
\newcommand{\swp}[2]{\mathbf{swp}[#1](#2)}
\newcommand{\Invariant}{\textit{Inv}}
\newcommand{\Inv}{\textit{Inv}}
\newcommand{\return}{\texttt{return}}
\newcommand{\nop}{\texttt{nop}}

% ---------- Auxiliary Variables and Symbols ----------
\newcommand{\cc}{C}
\newcommand{\ff}{\mathit{F}}
\newcommand{\X}{\textbf{X}}
\newcommand{\bb}{b}
\newcommand{\x}{\texttt{x}}
\newcommand{\y}{\texttt{y}}
\newcommand{\z}{\texttt{z}}
\newcommand{\ee}{\texttt{e}}
\newcommand{\F}{\textit{F}}
\newcommand{\A}{\mathfrak{A}}
\newcommand{\vv}{\mathit{v}}
\newcommand{\vu}{\mathit{u}}
\newcommand{\SetComp}[2]{\left\{ #1 \mid #2 \right\}}
\newcommand{\AX}{\textbf{AX}}
\newcommand{\fg}{G}
\newcommand{\WhileDoInv}[2]{\texttt{while}~(#1)~\texttt{invariant}~#2}
% ---------- Meta-Variables ----------
\newcommand{\Pre}{P}
\newcommand{\Post}{Q}
\newcommand{\confTerm}{\Done}

% ---------- Magic and Additional Commands ----------
\newcommand{\Magic}{\texttt{magic}}
\newcommand{\Declared}[1]{\textbf{Declared}(#1)}
\newcommand{\Mems}{\texttt{Mem}}
\newcommand{\Scopes}{\mathcal{S}}
\newcommand{\RestoreScope}{\texttt{RestoreScope}}
\newcommand{\enc}[1]{[#1]}
\newcommand{\Encode}[1]{\texttt{enc}(#1)}
\newcommand{\opStep}{\step}
\newcommand{\VarSet}{\texttt{Var}}
\newcommand{\Universe}{\mathfrak{A}}
\newcommand{\Set}[1]{\{#1\}}
\newcommand{\ModVarsOf}[1]{\mathbf{Mod}(#1)}
\newcommand{\xs}{\texttt{x}}
\newcommand{\ForDo}[4]{\texttt{for}~#1~\texttt{in}~#2..#3~\{#4\}}
\newcommand{\defq}{\stackrel{\text{def}}{=}}
$$